import React, { useState, useEffect, useRef, useMemo, useCallback } from 'react';
import { Upload, AlertCircle, Loader2, Database, Users, ChevronDown, LayoutGrid, Grid3X3, Sun, Moon, ArrowRightLeft, UserPlus, AlertTriangle, Briefcase, GripVertical, X, Wand2, Calendar, Filter, Search, CheckSquare, Square, Cloud, CloudOff, FileUp, CheckCircle2, Info, ChevronUp, Edit3, GraduationCap, Ban, UserCheck, ToggleLeft, ToggleRight, Table2, Save, XCircle, Trash2, Plus, MoreHorizontal, CalendarDays, Check, ArrowUpDown, SlidersHorizontal, UserMinus, FileCheck, Clock, Download, Zap } from 'lucide-react';
import * as XLSX from 'xlsx';
import ExcelJS from 'exceljs';
import { PerformanceView, useRenderTime } from './PerformanceMonitor';

// --- LOCAL STORAGE HELPERS ---
const STORAGE_KEYS = {
    RAW_TABLES: 'plan_raw_tables',
    MANUAL_ASSIGNMENTS: 'plan_manual_assignments',
    PLAN_HASHES: 'plan_hashes',
    LINE_TEMPLATES: 'plan_line_templates',
    WORKER_REGISTRY: 'plan_worker_registry',
    FLOATERS: 'plan_floaters',
    SCHEDULE_DATES: 'plan_schedule_dates',
    FACT_DATA: 'plan_fact_data',
    FACT_DATES: 'plan_fact_dates'
};

const saveToLocalStorage = (key, data) => {
    try {
        localStorage.setItem(key, JSON.stringify(data));
    } catch (e) {
        console.error('Error saving to localStorage:', e);
    }
};

const loadFromLocalStorage = (key, defaultValue = null) => {
    try {
        const item = localStorage.getItem(key);
        return item ? JSON.parse(item) : defaultValue;
    } catch (e) {
        console.error('Error loading from localStorage:', e);
        return defaultValue;
    }
};

// --- HELPERS ---
const debounce = (func, wait) => {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
};

const cleanVal = (val) => String(val ?? '').trim();
const extractShiftNumber = (str) => (String(str).match(/\d+/) || [])[0] || null;

const normalizeName = (name) => {
    return String(name).toLowerCase().replace(/ё/g, 'е').replace(/[^a-zа-я]/g, '');
};

// Улучшенная функция для сопоставления имен (сокращенных и полных)
const matchNames = (name1, name2) => {
    if (!name1 || !name2) return false;

    const n1 = String(name1).toLowerCase().trim();
    const n2 = String(name2).toLowerCase().trim();

    // Точное совпадение после нормализации
    if (normalizeName(n1) === normalizeName(n2)) return true;

    // Извлекаем части имени (фамилия, имя, отчество)
    const parts1 = n1.split(/\s+/).filter(p => p.length > 0);
    const parts2 = n2.split(/\s+/).filter(p => p.length > 0);

    if (parts1.length === 0 || parts2.length === 0) return false;

    // Фамилия должна совпадать (нормализованная)
    const surname1 = normalizeName(parts1[0]);
    const surname2 = normalizeName(parts2[0]);

    if (surname1 !== surname2) return false;

    // Если только фамилия - считаем совпадением
    if (parts1.length === 1 && parts2.length === 1) return true;

    // Сопоставление имени и отчества
    // Пример: "Беликов И. Д." vs "Беликов Илья Дмитриевич"
    // Пример: "Беликова Г. Н." vs "Беликова Галина Николаевна"

    // Получаем имя (вторая часть)
    const firstName1 = parts1.length >= 2 ? parts1[1].replace(/\./g, '').trim() : '';
    const firstName2 = parts2.length >= 2 ? parts2[1].trim() : '';

    // Получаем отчество (третья часть, если есть)
    const middleName1 = parts1.length >= 3 ? parts1[2].replace(/\./g, '').trim() : '';
    const middleName2 = parts2.length >= 3 ? parts2[2].trim() : '';

    // Сопоставление имени
    let firstNameMatch = false;
    if (firstName1 && firstName2) {
        // Если одно - инициал (1 символ), а другое - полное имя
        if (firstName1.length === 1 && firstName2.length > 1) {
            firstNameMatch = firstName1[0] === firstName2[0];
        } else if (firstName1.length > 1 && firstName2.length === 1) {
            firstNameMatch = firstName1[0] === firstName2[0];
        } else if (firstName1[0] === firstName2[0]) {
            // Оба полные или оба инициалы - сравниваем первую букву
            firstNameMatch = true;
        }
    } else if (!firstName1 && !firstName2) {
        firstNameMatch = true; // Оба без имени
    }

    // Сопоставление отчества
    let middleNameMatch = false;
    if (middleName1 && middleName2) {
        // Если одно - инициал, а другое - полное отчество
        if (middleName1.length === 1 && middleName2.length > 1) {
            middleNameMatch = middleName1[0] === middleName2[0];
        } else if (middleName1.length > 1 && middleName2.length === 1) {
            middleNameMatch = middleName1[0] === middleName2[0];
        } else if (middleName1[0] === middleName2[0]) {
            middleNameMatch = true;
        }
    } else if (!middleName1 && !middleName2) {
        middleNameMatch = true; // Оба без отчества
    } else if ((!middleName1 && middleName2) || (middleName1 && !middleName2)) {
        // Если в одном есть отчество, а в другом нет - тоже ок (может быть не указано)
        middleNameMatch = true;
    }

    // Если имя совпадает, проверяем отчество (если есть хотя бы в одном)
    if (firstNameMatch) {
        if (middleName1 || middleName2) {
            return middleNameMatch;
        }
        return true; // Имя совпало, отчества нет - считаем совпадением
    }

    // Дополнительная проверка: если фамилия совпадает и первые буквы имени совпадают
    if (firstName1 && firstName2 && firstName1[0] === firstName2[0]) {
        if (middleName1 && middleName2 && middleName1[0] === middleName2[0]) {
            return true;
        } else if (!middleName1 && !middleName2) {
            return true;
        }
    }

    // Проверка на включение (одно имя содержит другое) для длинных имен
    const n1Clean = normalizeName(n1);
    const n2Clean = normalizeName(n2);
    if (n1Clean.length > 8 && n2Clean.length > 8) {
        if (n1Clean.includes(n2Clean) || n2Clean.includes(n1Clean)) return true;
    }

    return false;
};

const isLineMatch = (planLine, rosterLine) => {
    if (!planLine || !rosterLine) return false;
    const p = String(planLine).toLowerCase().trim();
    const r = String(rosterLine).toLowerCase().trim();
    const pClean = p.replace(/[^a-zа-я0-9]/g, '');
    const rClean = r.replace(/[^a-zа-я0-9]/g, '');
    if (pClean === rClean) return true;
    if (pClean.length > 3 && rClean.length > 3) {
        if (pClean.includes(rClean) || rClean.includes(pClean)) return true;
    }
    const pNums = p.match(/\d+/g);
    const rNums = r.match(/\d+/g);
    if (pNums && rNums) {
        return pNums.some(pn => rNums.includes(pn));
    }
    return false;
};

const cyrb53 = (str, seed = 0) => {
    let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;
    for (let i = 0, ch; i < str.length; i++) {
        ch = str.charCodeAt(i);
        h1 = Math.imul(h1 ^ ch, 2654435761);
        h2 = Math.imul(h2 ^ ch, 1597334677);
    }
    h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^ Math.imul(h2 ^ (h2 >>> 13), 3266489909);
    h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^ Math.imul(h1 ^ (h1 >>> 13), 3266489909);
    return 4294967296 * (2097151 & h2) + (h1 >>> 0);
};

const parseWorkerStatus = (statusStr) => {
    if (!statusStr || statusStr.length < 5) return null;
    const lower = statusStr.toLowerCase();

    let type = null;
    if (lower.includes('отпуск')) type = 'vacation';
    else if (lower.includes('больничный')) type = 'sick';
    else if (lower.includes('увольнение') || lower.includes('уволен')) type = 'fired';

    if (!type) return null;

    const dateMatch = statusStr.match(/(\d{1,2})[\.\/](\d{1,2})\s*[-–—]\s*(\d{1,2})[\.\/](\d{1,2})/);

    if (dateMatch) {
        const currentYear = new Date().getFullYear();
        const fromDate = new Date(currentYear, parseInt(dateMatch[2]) - 1, parseInt(dateMatch[1]));
        let toDate = new Date(currentYear, parseInt(dateMatch[4]) - 1, parseInt(dateMatch[3]));
        if (toDate < fromDate) toDate.setFullYear(currentYear + 1);
        return { type, from: fromDate, to: toDate, raw: statusStr };
    }
    if (type === 'fired') return { type, raw: statusStr, permanent: true };
    return { type, raw: statusStr, permanent: false };
};

const checkWorkerAvailability = (workerName, dateStr, registry) => {
    if (!registry || !registry[workerName]) return { available: true };
    const statusData = registry[workerName].status;
    if (!statusData) return { available: true };

    const [d, m, y] = dateStr.split('.').map(Number);
    const targetDate = new Date(y, m - 1, d);

    const s = statusData;
    if (s.permanent) return { available: false, reason: s.raw, type: s.type };

    if (s.from && s.to) {
        targetDate.setHours(0, 0, 0, 0);
        const from = new Date(s.from); from.setHours(0, 0, 0, 0);
        const to = new Date(s.to); to.setHours(0, 0, 0, 0);
        if (targetDate >= from && targetDate <= to) return { available: false, reason: s.raw, type: s.type };
    }
    return { available: true };
};

const getRealNeighborDateStrings = (dateStr) => {
    const [d, m, y] = dateStr.split('.').map(Number);
    const date = new Date(y, m - 1, d);

    const prevDate = new Date(date);
    prevDate.setDate(date.getDate() - 1);

    const nextDate = new Date(date);
    nextDate.setDate(date.getDate() + 1);

    const format = (dt) => {
        const day = String(dt.getDate()).padStart(2, '0');
        const month = String(dt.getMonth() + 1).padStart(2, '0');
        const year = dt.getFullYear();
        return `${day}.${month}.${year}`;
    };

    return {
        prev: format(prevDate),
        next: format(nextDate)
    };
};

const combineAllTimeEntries = (allTimeInfos, foundDates) => {
    if (allTimeInfos.length === 0) return null;

    // Собираем все времена и сортируем по дате
    const sortedTimeInfos = allTimeInfos.sort((a, b) => {
        const dateA = foundDates.findIndex(d => d.date === a.date);
        const dateB = foundDates.findIndex(d => d.date === b.date);
        return dateA - dateB;
    });

    // Собираем все времена входа и выхода
    const allEntryTimes = [];
    const allExitTimes = [];
    let earliestDate = sortedTimeInfos[0].date;

    sortedTimeInfos.forEach(({ date, timeInfo }) => {
        // Время входа - это первое время в записи ИЛИ время если есть только одно время
        if (timeInfo.entryTime) {
            allEntryTimes.push({ time: timeInfo.entryTime, date });
        }

        // Время выхода - это второе время в записи ИЛИ nextDayExit для ночных смен
        if (timeInfo.exitTime) {
            allExitTimes.push({ time: timeInfo.exitTime, date });
        }
        if (timeInfo.nextDayExit) {
            allExitTimes.push({ time: timeInfo.nextDayExit, date: timeInfo.nextDayDate });
        }

        // Если есть только одно время и это не ночная смена - это может быть и вход и выход
        if (timeInfo.entryTime && !timeInfo.exitTime && !timeInfo.hasOvernightShift) {
            // Это может быть как вход так и выход - решаем по контексту
            const hour = parseInt(timeInfo.entryTime.match(/(\d{1,2}):/)[1]);
            if (hour < 12) {
                // Если время до 12:00 - скорее всего это вход (утренняя смена)
                allEntryTimes.push({ time: timeInfo.entryTime, date });
            } else {
                // Если время после 12:00 - может быть выход из дневной смены
                allExitTimes.push({ time: timeInfo.entryTime, date });
            }
        }
    });

    // Убираем дубликаты и сортируем
    const uniqueEntryTimes = [...new Map(allEntryTimes.map(item => [item.time, item])).values()]
        .sort((a, b) => a.time.localeCompare(b.time));
    const uniqueExitTimes = [...new Map(allExitTimes.map(item => [item.time, item])).values()]
        .sort((a, b) => a.time.localeCompare(b.time));

    // Берем самое раннее время входа и самое позднее время выхода
    const entryTime = uniqueEntryTimes[0] || null;
    const exitTime = uniqueExitTimes[uniqueExitTimes.length - 1] || null;

    // Определяем ночную смену
    let hasOvernightShift = false;
    let nextDayExit = null;
    let nextDayDate = null;

    if (entryTime && exitTime) {
        const entryHour = parseInt(entryTime.time.match(/(\d{1,2}):/)[1]);
        const exitHour = parseInt(exitTime.time.match(/(\d{1,2}):/)[1]);

        // Ночная смена только если:
        // 1. Выход на следующий день И
        // 2. Выход раньше входа ИЛИ (вход после 20:00 И выход до 6:00)
        if (exitTime.date !== entryTime.date &&
            (exitHour < entryHour || (entryHour >= 20 && exitHour <= 6))) {
            hasOvernightShift = true;
            nextDayExit = exitTime.time;
            nextDayDate = exitTime.date;
        }
    }

    const displayTime = hasOvernightShift && nextDayExit
        ? `${entryTime.time} → ${nextDayExit} (+1)`
        : entryTime && exitTime
            ? `${entryTime.time} → ${exitTime.time}`
            : entryTime?.time || exitTime?.time || '';

    return {
        displayTime,
        cleanTime: displayTime,
        entryTime: entryTime?.time || null,
        exitTime: hasOvernightShift ? null : exitTime?.time || null,
        hasOvernightShift,
        nextDayExit: hasOvernightShift ? nextDayExit : null,
        nextDayDate: hasOvernightShift ? nextDayDate : null,
        primaryDate: earliestDate
    };
};

// --- TIME COMBINATION HELPERS ---
const combineTimeEntries = (timeInfos, date, foundDates) => {
    if (timeInfos.length === 0) return null;
    if (timeInfos.length === 1) return timeInfos[0];

    // Собираем все времена из всех записей
    const allEntryTimes = [];
    const allExitTimes = [];
    let hasOvernight = false;
    let nextDayExit = null;
    let nextDayDate = null;

    timeInfos.forEach(info => {
        if (info.entryTime) allEntryTimes.push(info.entryTime);
        if (info.exitTime) allExitTimes.push(info.exitTime);
        if (info.hasOvernightShift) {
            hasOvernight = true;
            if (info.nextDayExit) {
                nextDayExit = info.nextDayExit;
                nextDayDate = info.nextDayDate;
            }
        }
    });

    // Убираем дубликаты и сортируем
    const uniqueEntryTimes = [...new Set(allEntryTimes)].sort();
    const uniqueExitTimes = [...new Set(allExitTimes)].sort();

    // Берем самое раннее время входа и самое позднее время выхода
    const entryTime = uniqueEntryTimes[0] || null;
    const exitTime = uniqueExitTimes[uniqueExitTimes.length - 1] || null;

    // Определяем ночную смену
    if (entryTime && exitTime) {
        const entryHour = parseInt(entryTime.match(/(\d{1,2}):/)[1]);
        const exitHour = parseInt(exitTime.match(/(\d{1,2}):/)[1]);

        if (exitHour < entryHour || (entryHour >= 20 && exitHour <= 6)) {
            hasOvernight = true;
            nextDayExit = exitTime;

            // Находим следующую дату
            const currentDateIndex = foundDates.findIndex(d => d.date === date);
            if (currentDateIndex !== -1 && currentDateIndex < foundDates.length - 1) {
                nextDayDate = foundDates[currentDateIndex + 1].date;
            }
        }
    }

    const displayTime = hasOvernight && nextDayExit
        ? `${entryTime} → ${nextDayExit} (+1)`
        : entryTime && exitTime
            ? `${entryTime} → ${exitTime}`
            : entryTime || exitTime || '';

    return {
        displayTime,
        cleanTime: displayTime,
        entryTime,
        exitTime: hasOvernight ? null : exitTime,
        hasOvernightShift: hasOvernight,
        nextDayExit: hasOvernight ? nextDayExit : null,
        nextDayDate: hasOvernight ? nextDayDate : null
    };
};

const mergeTimeEntries = (existing, newEntry) => {
    const result = { ...existing };

    // Объединяем времена входа
    const entryTimes = [];
    if (existing.entryTime) entryTimes.push(existing.entryTime);
    if (newEntry.entryTime) entryTimes.push(newEntry.entryTime);

    // Объединяем времена выхода
    const exitTimes = [];
    if (existing.exitTime) exitTimes.push(existing.exitTime);
    if (newEntry.exitTime) exitTimes.push(newEntry.exitTime);

    // Берем самое раннее время входа
    if (entryTimes.length > 0) {
        result.entryTime = entryTimes.sort()[0];
    }

    // Берем самое позднее время выхода
    if (exitTimes.length > 0) {
        result.exitTime = exitTimes.sort().pop();
    }

    // Обновляем ночную смену
    if (newEntry.hasOvernightShift) {
        result.hasOvernightShift = true;
        result.nextDayExit = newEntry.nextDayExit;
        result.nextDayDate = newEntry.nextDayDate;
    }

    // Обновляем отображаемое время
    if (result.hasOvernightShift && result.nextDayExit) {
        result.displayTime = `${result.entryTime} → ${result.nextDayExit} (+1)`;
    } else if (result.entryTime && result.exitTime) {
        result.displayTime = `${result.entryTime} → ${result.exitTime}`;
    } else {
        result.displayTime = result.entryTime || result.exitTime || '';
    }

    result.cleanTime = result.displayTime;

    return result;
};

// Строгий парсинг ячейки: [ВремяВхода, ВремяВыхода]
const parseCellStrict = (cellValue) => {
    if (!cellValue || typeof cellValue !== 'string') return { inTime: null, outTime: null };

    // Разбиваем по переносу строки. 
    // В Excel это часто \r\n или \n.
    const parts = cellValue.split(/\r?\n/);

    const cleanTime = (t) => {
        if (!t) return null;
        const clean = t.trim().toLowerCase();
        if (clean === 'нет' || clean === '' || !clean.includes(':')) return null;
        // Извлекаем HH:MM
        const match = clean.match(/(\d{1,2}):(\d{2})/);
        return match ? match[0] : null;
    };

    let rawIn = parts[0];
    let rawOut = parts.length > 1 ? parts[parts.length - 1] : null; // Берем последнюю, если строк > 2

    return {
        inTime: cleanTime(rawIn),
        outTime: cleanTime(rawOut)
    };
};
const parseTimeEntry = (timeStr, currentDate, foundDates) => {
    if (!timeStr || typeof timeStr !== 'string') {
        return { displayTime: timeStr, cleanTime: '', entryTime: null, exitTime: null, hasOvernightShift: false };
    }

    // Разделяем строки и обрабатываем каждую отдельно
    const lines = timeStr.split('\n').filter(line => line.trim());

    // Ищем времена в каждой строке
    const times = [];
    lines.forEach(line => {
        const cleanLine = line.trim();
        if (cleanLine && cleanLine !== 'нет') {
            const timeMatches = cleanLine.match(/(\d{1,2}):(\d{2})/);
            if (timeMatches) {
                times.push(timeMatches[0]); // Берем полное время с секундами
            }
        }
    });

    if (times.length === 0) {
        return { displayTime: timeStr, cleanTime: '', entryTime: null, exitTime: null, hasOvernightShift: false };
    }

    // Убираем секунды для отображения
    const cleanTimes = times.map(time => time.substring(0, 5)); // HH:MM

    // Если только одно время
    if (cleanTimes.length === 1) {
        const timeMatch = cleanTimes[0].match(/(\d{1,2}):(\d{2})/);
        if (timeMatch) {
            const [_, hours, minutes] = timeMatch;
            const hour = parseInt(hours);
            // Если время после 20:00, предполагаем что это начало ночной смены
            const isNightShiftStart = hour >= 20;
            return {
                displayTime: cleanTimes[0],
                cleanTime: cleanTimes[0],
                entryTime: cleanTimes[0],
                exitTime: null,
                hasOvernightShift: isNightShiftStart
            };
        }
        return { displayTime: timeStr, cleanTime: '', entryTime: null, exitTime: null, hasOvernightShift: false };
    }

    // Если несколько времен (первое - вход, последнее - выход)
    const entryTime = cleanTimes[0];
    const exitTime = cleanTimes[cleanTimes.length - 1];

    let hasOvernightShift = false;
    let nextDayExit = null;
    let nextDayDate = null;

    if (entryTime && exitTime) {
        const entryHour = parseInt(entryTime.match(/(\d{1,2}):/)[1]);
        const exitHour = parseInt(exitTime.match(/(\d{1,2}):/)[1]);

        // Если выход раньше входа, значит переход через полночь
        if (exitHour < entryHour || (entryHour >= 20 && exitHour <= 6)) {
            hasOvernightShift = true;
            nextDayExit = exitTime;

            // Находим следующую дату в списке дат
            const currentDateIndex = foundDates.findIndex(d => d.date === currentDate);
            if (currentDateIndex !== -1 && currentDateIndex < foundDates.length - 1) {
                nextDayDate = foundDates[currentDateIndex + 1].date;
            }
        }
    }

    const displayTime = hasOvernightShift
        ? `${entryTime} → ${exitTime} (+1)`
        : `${entryTime} → ${exitTime}`;

    return {
        displayTime,
        cleanTime: displayTime,
        entryTime,
        exitTime: hasOvernightShift ? null : exitTime, // Для ночных смен выход показываем на след день
        hasOvernightShift,
        nextDayExit,
        nextDayDate
    };
};

// --- COMPONENTS ---

const VerificationView = ({ getShiftsForDate, workerRegistry, factData, setFactData, factDates, setFactDates }) => {
    const [selectedDate, setSelectedDate] = useState(factDates && factDates.length > 0 ? factDates[0] : '');
    const [isLoading, setIsLoading] = useState(false);
    const fileRef = useRef(null);

    // Filter states
    const [statusFilter, setStatusFilter] = useState('all'); // all, ok, missing, unexpected
    const [search, setSearch] = useState('');
    const [verificationPage, setVerificationPage] = useState(1);
    const [verificationShowAll, setVerificationShowAll] = useState(false);

    // Сброс пагинации при изменении фильтров
    useEffect(() => {
        setVerificationPage(1);
    }, [search, statusFilter, selectedDate]);

    const handleFileUpload = (e) => {
        const file = e.target.files[0];
        if (!file) return;

        setIsLoading(true);

        const reader = new FileReader();
        reader.onload = (evt) => {
            try {
                const bstr = evt.target.result;
                const wb = XLSX.read(bstr, { type: 'binary' });
                const wsname = wb.SheetNames[0];
                const ws = wb.Sheets[wsname];
                const data = XLSX.utils.sheet_to_json(ws, { header: 1, defval: '' });

                // Find the header row with dates
                let dateRowIndex = -1;
                let foundDates = [];

                // Scan first 10 rows for dates
                for (let i = 0; i < Math.min(10, data.length); i++) {
                    const row = data[i];
                    const datesInRow = [];
                    row.forEach((cell, colIdx) => {
                        if (typeof cell === 'string' && cell.match(/^\d{2}\.\d{2}\.\d{4}$/)) {
                            datesInRow.push({ date: cell, colIdx });
                        }
                    });
                    if (datesInRow.length > 0) {
                        dateRowIndex = i;
                        foundDates = datesInRow;
                        break;
                    }
                }

                if (dateRowIndex === -1) {
                    alert('Не удалось найти даты в файле (формат ДД.ММ.ГГГГ)');
                    setIsLoading(false);
                    return;
                }

                // Parse employee data
                const parsedFact = {}; // Date -> { NormalizedName -> TimeString }
                foundDates.forEach(d => parsedFact[d.date] = {});

                // 1. Собираем сырые данные по нормализованным именам
                const timelineData = {}; // NormName -> { rawName, events: [ {date, colIdx, val} ] }

                for (let i = dateRowIndex + 1; i < data.length; i++) {
                    const row = data[i];
                    let name = row[3];
                    if (!name || name.length < 5) name = row[2];

                    if (name && typeof name === 'string' && name.length > 3) {
                        const normName = normalizeName(name);

                        if (!timelineData[normName]) {
                            timelineData[normName] = { rawName: name, events: [] };
                        }

                        // Собираем все ячейки этого сотрудника в хронологическом порядке
                        foundDates.forEach(({ date, colIdx }) => {
                            const timeVal = row[colIdx];
                            // Добавляем даже пустые, чтобы сохранить последовательность дат
                            timelineData[normName].events.push({ date, val: timeVal });
                        });
                    }
                }

                // 2. Обрабатываем таймлайн каждого сотрудника (Склейка смен)
                Object.values(timelineData).forEach(({ rawName, events }) => {
                    const normName = normalizeName(rawName);

                    let pendingShift = null; // Здесь будем хранить "висящую" ночную смену

                    events.forEach((event, index) => {
                        const { date, val } = event;
                        const { inTime, outTime } = parseCellStrict(val);

                        // Инициализируем хранилище для даты
                        if (!parsedFact[date]) parsedFact[date] = {};

                        let entryToWrite = null;

                        // СЦЕНАРИЙ 1: Завершение вчерашней ночной смены
                        if (pendingShift) {
                            // Если вчера был вход, а сегодня мы видим выход
                            let exitForNightShift = outTime;

                            if (exitForNightShift) {
                                // Записываем смену ВЧЕРАШНИМ числом (когда она началась), указывая выход "завтра"
                                const shiftDate = pendingShift.date;
                                if (!parsedFact[shiftDate]) parsedFact[shiftDate] = {};

                                parsedFact[shiftDate][normName] = {
                                    rawName,
                                    time: `${pendingShift.time} → ${exitForNightShift} (+1)`,
                                    cleanTime: `${pendingShift.time} → ${exitForNightShift} (+1)`,
                                    entryTime: pendingShift.time,
                                    exitTime: null, // null, потому что выход на след день
                                    hasOvernightShift: true,
                                    nextDayExit: exitForNightShift,
                                    nextDayDate: date,
                                    primaryDate: shiftDate
                                };

                                pendingShift = null; // Смена закрыта
                            }

                            // Если в этой же ячейке есть inTime (например 19:00), то это начало НОВОЙ смены сегодня
                            if (inTime) {
                                pendingShift = { time: inTime, date: date };
                            }
                            return; // Переходим к следующей дате
                        }

                        // СЦЕНАРИЙ 2: Обычная дневная смена (Вход и Выход в один день)
                        if (inTime && outTime) {
                            parsedFact[date][normName] = {
                                rawName,
                                time: `${inTime} → ${outTime}`,
                                cleanTime: `${inTime} → ${outTime}`,
                                entryTime: inTime,
                                exitTime: outTime,
                                hasOvernightShift: false
                            };
                            pendingShift = null;
                        }
                        // СЦЕНАРИЙ 3: Начало ночной смены (Есть вход, нет выхода)
                        else if (inTime && !outTime) {
                            pendingShift = { time: inTime, date: date };

                            // Сразу отображаем "Вход...", пока не найдем выход завтра
                            parsedFact[date][normName] = {
                                rawName,
                                time: `Вход: ${inTime}...`,
                                cleanTime: `Вход: ${inTime}`,
                                entryTime: inTime,
                                exitTime: null,
                                hasOvernightShift: true // Предполагаем ночь
                            };
                        }
                        // СЦЕНАРИЙ 4: Только выход (странная ситуация, если нет pendingShift)
                        else if (!inTime && outTime) {
                            // Это может быть хвост смены, начало которой мы не загрузили
                            // Игнорируем или пишем как есть
                        }
                    });
                });

                setFactData(parsedFact);
                const dates = foundDates.map(d => d.date);
                setFactDates(dates);

                // Сохраняем в localStorage
                saveToLocalStorage(STORAGE_KEYS.FACT_DATA, parsedFact);
                saveToLocalStorage(STORAGE_KEYS.FACT_DATES, dates);

                if (dates.length > 0) setSelectedDate(dates[0]);

            } catch (err) {
                console.error(err);
                alert('Ошибка чтения файла');
            } finally {
                setIsLoading(false);
            }
        };
        reader.readAsBinaryString(file);
    };

    const comparisonResult = useMemo(() => {
        if (!selectedDate || !factData || !factData[selectedDate]) return [];

        const shifts = getShiftsForDate(selectedDate);
        const dayFact = factData[selectedDate];
        const result = [];
        const processedFactNames = new Set();

        // ===== ОПТИМИЗАЦИЯ: Создаем Map-индексы для O(1) поиска =====
        // Индекс 1: по нормализованному ключу объекта
        const factByNormKey = new Map();
        // Индекс 2: по нормализованному rawName
        const factByNormRawName = new Map();
        // Индекс 3: все записи для последующего fuzzy/matchNames поиска
        const allFactEntries = [];

        Object.entries(dayFact).forEach(([key, value]) => {
            if (!value) return;

            const normKey = normalizeName(key);
            factByNormKey.set(normKey, value);

            if (value.rawName) {
                const normRawName = normalizeName(value.rawName);
                factByNormRawName.set(normRawName, value);
                allFactEntries.push({ key, value, normKey, normRawName });
            }
        });
        // ===== КОНЕЦ ОПТИМИЗАЦИИ =====

        // 1. Check Plan vs Fact
        shifts.forEach(shift => {
            shift.lineTasks.forEach(task => {
                task.slots.forEach(slot => {
                    if ((slot.status === 'filled' || slot.status === 'manual' || slot.status === 'reassigned') && slot.assigned) {
                        const planName = slot.assigned.name;
                        const normName = normalizeName(planName);

                        // ===== БЫСТРЫЙ ПОИСК С ИСПОЛЬЗОВАНИЕМ MAP =====
                        // 1. Попытка точного совпадения по ключу
                        let factEntry = dayFact[normName] || factByNormKey.get(normName);

                        // 2. Попытка по нормализованному rawName
                        if (!factEntry) {
                            factEntry = factByNormRawName.get(normName);
                        }

                        // 3. Улучшенное сопоставление через matchNames (только если не нашли выше)
                        if (!factEntry) {
                            const found = allFactEntries.find(({ value }) => {
                                return value.rawName && matchNames(planName, value.rawName);
                            });
                            if (found) factEntry = found.value;
                        }

                        // 4. Fuzzy поиск (contains) - только в крайнем случае
                        if (!factEntry) {
                            const found = allFactEntries.find(({ normKey, value }) => {
                                // Check by key
                                if (normKey.includes(normName) || normName.includes(normKey)) return true;
                                // Check by rawName через matchNames
                                if (value.rawName) {
                                    return matchNames(planName, value.rawName);
                                }
                                return false;
                            });
                            if (found) factEntry = found.value;
                        }
                        // ===== КОНЕЦ БЫСТРОГО ПОИСКА =====

                        if (factEntry) processedFactNames.add(normalizeName(factEntry.rawName));

                        let status = 'ok';
                        let timeDisplay = factEntry ? factEntry.time : '-';

                        // Улучшенная логика определения статуса с учетом входов/выходов
                        if (!factEntry || !factEntry.cleanTime) {
                            status = 'missing';
                        } else if (factEntry.hasOvernightShift && factEntry.nextDayExit) {
                            // Ночная смена с полными данными
                            status = 'ok';
                            timeDisplay = `${factEntry.entryTime} → ${factEntry.nextDayExit} (+1)`;
                        } else if (factEntry.hasOvernightShift) {
                            // Ночная смена (только вход)
                            status = 'ok';
                            timeDisplay = `Вход: ${factEntry.entryTime} (ночная)`;
                        } else if (factEntry.entryTime && !factEntry.exitTime) {
                            // Есть вход но нет выхода
                            status = 'ok';
                            timeDisplay = `Вход: ${factEntry.entryTime}`;
                        } else if (factEntry.entryTime && factEntry.exitTime) {
                            // Обычная смена с входом и выходом
                            status = 'ok';
                            timeDisplay = `${factEntry.entryTime} → ${factEntry.exitTime}`;
                        } else {
                            status = 'ok';
                            timeDisplay = factEntry.time;
                        }

                        result.push({
                            name: planName,
                            role: slot.roleTitle,
                            shift: shift.name,
                            line: task.displayName,
                            plan: true,
                            fact: !!(factEntry && factEntry.cleanTime),
                            time: timeDisplay,
                            status,
                            details: slot.assigned,
                            timeInfo: factEntry
                        });
                    }
                });
            });
        });

        // 2. Check Fact vs Plan (Unexpected guests)
        // ===== ОПТИМИЗАЦИЯ: Создаем Map для workerRegistry =====
        const registryByNormName = new Map();
        const registryEntries = Object.values(workerRegistry);
        registryEntries.forEach(w => {
            if (w && w.name) {
                const normRegName = normalizeName(w.name);
                registryByNormName.set(normRegName, w);
            }
        });
        // ===== КОНЕЦ ОПТИМИЗАЦИИ =====

        Object.values(dayFact).forEach(entry => {
            if (!entry || !entry.rawName) return;

            const normName = normalizeName(entry.rawName);
            // Проверяем, был ли этот сотрудник обработан в плане (используя улучшенное сопоставление)
            const wasProcessed = processedFactNames.has(normName) ||
                Array.from(processedFactNames).some(processedName => {
                    // Находим исходное имя из плана по нормализованному ключу
                    const planName = Object.keys(dayFact).find(k => normalizeName(dayFact[k]?.rawName || k) === processedName);
                    if (planName && dayFact[planName]?.rawName) {
                        return matchNames(entry.rawName, dayFact[planName].rawName);
                    }
                    return false;
                });

            if (!wasProcessed && entry.cleanTime) {
                // ===== БЫСТРЫЙ ПОИСК В РЕЕСТРЕ =====
                // 1. Попытка точного совпадения по нормализованному имени
                let regEntry = registryByNormName.get(normName);

                // 2. Если не найдено, попробуем через matchNames
                if (!regEntry) {
                    regEntry = registryEntries.find(w => {
                        return w && w.name && matchNames(w.name, entry.rawName);
                    });
                }
                // ===== КОНЕЦ БЫСТРОГО ПОИСКА =====

                let timeDisplay = entry.time;
                if (entry.hasOvernightShift && entry.nextDayExit) {
                    timeDisplay = `${entry.entryTime} → ${entry.nextDayExit} (+1)`;
                } else if (entry.hasOvernightShift) {
                    timeDisplay = `Вход: ${entry.entryTime} (ночная)`;
                } else if (entry.entryTime && entry.exitTime) {
                    timeDisplay = `${entry.entryTime} → ${entry.exitTime}`;
                } else if (entry.entryTime && !entry.exitTime) {
                    timeDisplay = `Вход: ${entry.entryTime}`;
                }

                result.push({
                    name: entry.rawName,
                    role: regEntry ? regEntry.role : 'Неизвестно',
                    shift: '-',
                    line: '-',
                    plan: false,
                    fact: true,
                    time: timeDisplay,
                    status: 'unexpected',
                    details: regEntry,
                    timeInfo: entry
                });
            }
        });

        return result;
    }, [selectedDate, factData, getShiftsForDate, workerRegistry]);

    const filteredResult = comparisonResult.filter(r => {
        if (search && !r.name.toLowerCase().includes(search.toLowerCase())) return false;
        if (statusFilter === 'ok' && r.status !== 'ok') return false;
        if (statusFilter === 'missing' && r.status !== 'missing') return false;
        if (statusFilter === 'unexpected' && r.status !== 'unexpected') return false;
        return true;
    });

    // Пагинация для сверки
    const ITEMS_PER_PAGE_VERIFICATION = 50;
    const totalPagesVerification = Math.ceil(filteredResult.length / ITEMS_PER_PAGE_VERIFICATION);
    const paginatedResult = verificationShowAll ? filteredResult : filteredResult.slice(
        (verificationPage - 1) * ITEMS_PER_PAGE_VERIFICATION,
        verificationPage * ITEMS_PER_PAGE_VERIFICATION
    );

    const stats = {
        total: comparisonResult.length,
        ok: comparisonResult.filter(r => r.status === 'ok').length,
        missing: comparisonResult.filter(r => r.status === 'missing').length,
        unexpected: comparisonResult.filter(r => r.status === 'unexpected').length
    };

    if (!factData) {
        return (
            <div className="flex flex-col items-center justify-center h-full p-10">
                <div
                    onClick={() => fileRef.current?.click()}
                    className="border-2 border-dashed border-slate-300 rounded-xl p-12 flex flex-col items-center cursor-pointer hover:bg-slate-50 hover:border-blue-400 transition-all text-slate-500"
                >
                    <div className="bg-blue-100 p-4 rounded-full text-blue-600 mb-4">
                        <FileCheck size={40} />
                    </div>
                    <h3 className="text-xl font-bold text-slate-700 mb-2">Загрузить отчет СКУД</h3>
                    <p className="text-sm max-w-xs text-center mb-6">Загрузите файл .xls/.csv (выгрузка ЭНТ) для сверки фактических выходов с планом</p>
                    <button className="bg-blue-600 text-white px-6 py-2 rounded-lg font-semibold hover:bg-blue-700 transition-colors">
                        Выбрать файл
                    </button>
                    <input type="file" ref={fileRef} onChange={handleFileUpload} className="hidden" accept=".csv, .xls, .xlsx" />
                </div>
            </div>
        );
    }

    return (
        <div className="h-full flex flex-col bg-slate-50">
            <div className="bg-white border-b border-slate-200 px-6 py-4 flex flex-col md:flex-row justify-between items-center gap-4 flex-shrink-0">
                <div className="flex items-center gap-4">
                    <div className="bg-blue-100 p-2 rounded-lg text-blue-700">
                        <FileCheck size={24} />
                    </div>
                    <div>
                        <h2 className="text-lg font-bold text-slate-800">Сверка факта</h2>
                        <div className="flex items-center gap-4 text-xs text-slate-500 mt-1">
                            <span className="flex items-center gap-1 text-green-600 font-bold"><CheckCircle2 size={12} /> Пришли: {stats.ok}</span>
                            <span className="flex items-center gap-1 text-red-500 font-bold"><AlertCircle size={12} /> Прогулы: {stats.missing}</span>
                            <span className="flex items-center gap-1 text-orange-500 font-bold"><UserPlus size={12} /> Лишние: {stats.unexpected}</span>
                        </div>
                    </div>
                </div>

                <div className="flex items-center gap-3">
                    <div className="relative">
                        <Calendar size={16} className="absolute left-3 top-1/2 -translate-y-1/2 text-slate-400" />
                        <select
                            value={selectedDate}
                            onChange={e => setSelectedDate(e.target.value)}
                            className="pl-9 pr-8 py-2 bg-slate-100 border border-slate-200 rounded-lg text-sm font-bold text-slate-700 outline-none focus:ring-2 focus:ring-blue-500"
                        >
                            {factDates.map(d => <option key={d} value={d}>{d}</option>)}
                        </select>
                    </div>
                    <div className="h-8 w-px bg-slate-200"></div>
                    <button onClick={() => {
                        setFactData(null);
                        setFactDates([]);
                        saveToLocalStorage(STORAGE_KEYS.FACT_DATA, null);
                        saveToLocalStorage(STORAGE_KEYS.FACT_DATES, []);
                    }} className="text-slate-400 hover:text-red-500 p-2 hover:bg-red-50 rounded-lg transition-colors" title="Сбросить файл">
                        <Trash2 size={20} />
                    </button>
                </div>
            </div>

            <div className="flex-1 flex flex-col overflow-hidden p-6 max-w-[1400px] mx-auto w-full">
                <div className="mb-4 flex gap-4">
                    <div className="relative flex-1 max-w-sm">
                        <Search size={16} className="absolute left-3 top-1/2 -translate-y-1/2 text-slate-400" />
                        <input
                            type="text"
                            placeholder="Поиск сотрудника..."
                            value={search}
                            onChange={e => setSearch(e.target.value)}
                            className="w-full pl-9 pr-4 py-2 bg-white border border-slate-200 rounded-lg text-sm outline-none focus:ring-2 focus:ring-blue-500 shadow-sm"
                        />
                    </div>
                    <div className="flex bg-white rounded-lg p-1 border border-slate-200 shadow-sm">
                        {[{ id: 'all', l: 'Все' }, { id: 'ok', l: 'Совпадения' }, { id: 'missing', l: 'Прогулы' }, { id: 'unexpected', l: 'Вне плана' }].map(tab => (
                            <button
                                key={tab.id}
                                onClick={() => setStatusFilter(tab.id)}
                                className={`px-4 py-1.5 rounded-md text-xs font-bold transition-all ${statusFilter === tab.id ? 'bg-slate-800 text-white' : 'text-slate-500 hover:text-slate-700 hover:bg-slate-50'}`}
                            >
                                {tab.l}
                            </button>
                        ))}
                    </div>
                </div>

                <div className="bg-white rounded-xl shadow-sm border border-slate-200 overflow-hidden flex-1">
                    <div className="overflow-auto h-full">
                        <table className="w-full text-sm text-left">
                            <thead className="bg-slate-50 text-slate-500 font-semibold sticky top-0 z-10 shadow-sm">
                                <tr>
                                    <th className="px-6 py-3 border-b">Сотрудник</th>
                                    <th className="px-6 py-3 border-b">План (Смена)</th>
                                    <th className="px-6 py-3 border-b">Факт (Время)</th>
                                    <th className="px-6 py-3 border-b text-center">Статус</th>
                                </tr>
                            </thead>
                            <tbody className="divide-y divide-slate-100">
                                {paginatedResult.map((row, i) => {
                                    let statusBadge;
                                    let rowClass = '';

                                    if (row.status === 'ok') {
                                        statusBadge = <span className="bg-green-100 text-green-700 px-2 py-1 rounded-full text-xs font-bold inline-flex items-center gap-1"><CheckCircle2 size={12} /> Пришел</span>;
                                    } else if (row.status === 'missing') {
                                        statusBadge = <span className="bg-red-100 text-red-700 px-2 py-1 rounded-full text-xs font-bold inline-flex items-center gap-1"><XCircle size={12} /> Не пришел</span>;
                                        rowClass = 'bg-red-50/30';
                                    } else if (row.status === 'unexpected') {
                                        statusBadge = <span className="bg-orange-100 text-orange-700 px-2 py-1 rounded-full text-xs font-bold inline-flex items-center gap-1"><AlertCircle size={12} /> Не в смену</span>;
                                        rowClass = 'bg-orange-50/30';
                                    }

                                    return (
                                        <tr key={i} className={`hover:bg-slate-50 transition-colors ${rowClass}`}>
                                            <td className="px-6 py-3">
                                                <div className="font-bold text-slate-700">{row.name}</div>
                                                <div className="text-xs text-slate-500">{row.role}</div>
                                            </td>
                                            <td className="px-6 py-3 text-slate-600">
                                                {row.plan ? (
                                                    <div>
                                                        <div className="font-semibold">{row.line}</div>
                                                        <div className="text-xs">Бригада {row.shift}</div>
                                                    </div>
                                                ) : (
                                                    <span className="text-slate-400 italic">Не запланирован</span>
                                                )}
                                            </td>
                                            <td className="px-6 py-3">
                                                {row.fact ? (
                                                    <div className="space-y-1">
                                                        <div className={`font-mono text-sm px-2 py-1 rounded inline-block border text-center ${row.timeInfo?.hasOvernightShift
                                                                ? 'bg-blue-50 text-blue-700 border-blue-200'
                                                                : 'bg-slate-100 text-slate-700 border-slate-200'
                                                            }`}>
                                                            {row.time}
                                                        </div>
                                                        {row.timeInfo?.hasOvernightShift && (
                                                            <div className="text-xs text-blue-600 font-medium">
                                                                {row.timeInfo?.nextDayExit
                                                                    ? `Ночная смена (выход ${row.timeInfo.nextDayExit} на след. день)`
                                                                    : 'Ночная смена'
                                                                }
                                                            </div>
                                                        )}
                                                        {row.timeInfo?.entryTime && row.timeInfo?.exitTime && !row.timeInfo?.hasOvernightShift && (
                                                            <div className="text-xs text-slate-500">
                                                                Вход: {row.timeInfo.entryTime} | Выход: {row.timeInfo.exitTime}
                                                            </div>
                                                        )}
                                                    </div>
                                                ) : (
                                                    <span className="text-slate-300">—</span>
                                                )}
                                            </td>
                                            <td className="px-6 py-3 text-center">
                                                {statusBadge}
                                            </td>
                                        </tr>
                                    );
                                })}
                                {paginatedResult.length === 0 && (
                                    <tr>
                                        <td colSpan={4} className="text-center py-10 text-slate-400">
                                            Ничего не найдено
                                        </td>
                                    </tr>
                                )}
                            </tbody>
                        </table>
                        
                        {/* Панель пагинации для сверки */}
                        {filteredResult.length > ITEMS_PER_PAGE_VERIFICATION && (
                            <div className="border-t border-slate-200 p-4 bg-slate-50 flex flex-col sm:flex-row justify-between items-center gap-4">
                                <div className="flex items-center gap-4 text-sm text-slate-600">
                                    <span>Показано <b>{paginatedResult.length}</b> из <b>{filteredResult.length}</b> записей</span>
                                    {!verificationShowAll && (
                                        <span>Страница {verificationPage} из {totalPagesVerification}</span>
                                    )}
                                </div>
                                <div className="flex items-center gap-2">
                                    {!verificationShowAll && (
                                        <>
                                            <button
                                                onClick={() => setVerificationPage(Math.max(1, verificationPage - 1))}
                                                disabled={verificationPage === 1}
                                                className="px-3 py-1.5 bg-white border border-slate-200 rounded-lg text-sm font-medium text-slate-600 hover:bg-slate-50 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
                                            >
                                                ←
                                            </button>
                                            <div className="flex items-center gap-1">
                                                {Array.from({ length: Math.min(5, totalPagesVerification) }, (_, i) => {
                                                    let pageNum;
                                                    if (totalPagesVerification <= 5) {
                                                        pageNum = i + 1;
                                                    } else if (verificationPage <= 3) {
                                                        pageNum = i + 1;
                                                    } else if (verificationPage >= totalPagesVerification - 2) {
                                                        pageNum = totalPagesVerification - 4 + i;
                                                    } else {
                                                        pageNum = verificationPage - 2 + i;
                                                    }
                                                    return (
                                                        <button
                                                            key={pageNum}
                                                            onClick={() => setVerificationPage(pageNum)}
                                                            className={`px-3 py-1.5 rounded-lg text-sm font-medium transition-colors ${
                                                                verificationPage === pageNum 
                                                                    ? 'bg-blue-600 text-white' 
                                                                    : 'bg-white border border-slate-200 text-slate-600 hover:bg-slate-50'
                                                            }`}
                                                        >
                                                            {pageNum}
                                                        </button>
                                                    );
                                                })}
                                            </div>
                                            <button
                                                onClick={() => setVerificationPage(Math.min(totalPagesVerification, verificationPage + 1))}
                                                disabled={verificationPage === totalPagesVerification}
                                                className="px-3 py-1.5 bg-white border border-slate-200 rounded-lg text-sm font-medium text-slate-600 hover:bg-slate-50 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
                                            >
                                                →
                                            </button>
                                        </>
                                    )}
                                    <button
                                        onClick={() => {
                                            setVerificationShowAll(!verificationShowAll);
                                            if (!verificationShowAll) setVerificationPage(1);
                                        }}
                                        className={`px-4 py-1.5 rounded-lg text-sm font-medium transition-colors ${
                                            verificationShowAll 
                                                ? 'bg-orange-100 text-orange-700 border border-orange-200' 
                                                : 'bg-blue-600 text-white hover:bg-blue-700'
                                        }`}
                                    >
                                        {verificationShowAll ? 'Ограничить' : 'Показать все'}
                                    </button>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            </div>
        </div>
    );
};

const MatrixAssignmentModal = ({ isOpen, onClose, context, currentNames, workerRegistry, lineTemplates, onSave }) => {
    const [searchTerm, setSearchTerm] = useState('');
    const [selectedWorkers, setSelectedWorkers] = useState([]);

    useEffect(() => {
        if (isOpen) {
            const initialList = currentNames
                ? currentNames.split(/[,;\n/]+/).map(s => s.trim()).filter(s => s.length > 1)
                : [];
            setSelectedWorkers(initialList);
            setSearchTerm('');
        }
    }, [isOpen, currentNames]);

    // UPDATED: Global scan across ALL shifts and lines
    const workerLocations = useMemo(() => {
        const locations = {}; // Name -> { line, shift, role }
        if (!isOpen || !lineTemplates) return locations;

        Object.entries(lineTemplates).forEach(([lineName, positions]) => {
            positions.forEach(pos => {
                Object.entries(pos.roster).forEach(([sId, namesStr]) => {
                    if (namesStr) {
                        const names = namesStr.split(/[,;\n/]+/).map(s => s.trim()).filter(s => s.length > 1);
                        names.forEach(name => {
                            const isCurrentCell = (lineName === context?.lineName) && (pos.role === context?.role) && (sId === context?.shiftId);
                            if (!isCurrentCell) {
                                locations[name] = { line: lineName, shift: sId, role: pos.role };
                            }
                        });
                    }
                });
            });
        });
        return locations;
    }, [isOpen, context, lineTemplates]);

    if (!isOpen) return null;

    const allWorkers = Object.values(workerRegistry).sort((a, b) => a.name.localeCompare(b.name));

    const filteredWorkers = allWorkers.filter(w => {
        if (selectedWorkers.includes(w.name)) return false;
        const matchName = w.name.toLowerCase().includes(searchTerm.toLowerCase());
        const matchRole = w.role && w.role.toLowerCase().includes(searchTerm.toLowerCase());
        return matchName || matchRole;
    });

    const handleAdd = (name) => {
        setSelectedWorkers([...selectedWorkers, name]);
    };

    const handleRemove = (name) => {
        setSelectedWorkers(selectedWorkers.filter(w => w !== name));
    };

    const handleCreateNew = () => {
        if (searchTerm.trim()) {
            handleAdd(searchTerm.trim());
            setSearchTerm('');
        }
    };

    const handleSaveInternal = () => {
        onSave(selectedWorkers);
        onClose();
    };

    return (
        <div className="fixed inset-0 bg-slate-900/50 backdrop-blur-sm z-50 flex items-center justify-center p-4">
            <div className="bg-white rounded-2xl shadow-xl w-full max-w-lg flex flex-col max-h-[85vh]">
                <div className="bg-slate-50 px-6 py-4 border-b border-slate-100 flex justify-between items-center rounded-t-2xl">
                    <div>
                        <h3 className="font-bold text-lg text-slate-800">Назначение на линию</h3>
                        <div className="text-xs text-slate-500 mt-0.5">{context?.lineName} • {context?.role} • Смена {context?.shiftId}</div>
                    </div>
                    <button onClick={onClose}><X size={20} className="text-slate-400 hover:text-slate-600" /></button>
                </div>

                <div className="p-4 flex-1 overflow-hidden flex flex-col">
                    <div className="mb-4">
                        <label className="text-xs font-bold text-slate-500 uppercase mb-2 block">Выбраны ({selectedWorkers.length})</label>
                        <div className="flex flex-wrap gap-2 p-3 bg-blue-50/50 rounded-xl border border-blue-100 min-h-[50px]">
                            {selectedWorkers.length === 0 ? (
                                <span className="text-slate-400 text-sm italic self-center">Никого не выбрано</span>
                            ) : (
                                selectedWorkers.map(name => (
                                    <div key={name} className="bg-white border border-blue-200 text-blue-800 text-sm px-2 py-1 rounded-lg flex items-center gap-2 shadow-sm animate-in zoom-in duration-200">
                                        <span className="font-medium">{name}</span>
                                        <button onClick={() => handleRemove(name)} className="text-blue-400 hover:text-red-500"><X size={14} /></button>
                                    </div>
                                ))
                            )}
                        </div>
                    </div>

                    <div className="flex-1 flex flex-col min-h-0">
                        <div className="relative mb-2">
                            <Search size={16} className="absolute left-3 top-1/2 -translate-y-1/2 text-slate-400" />
                            <input
                                type="text"
                                placeholder="Поиск сотрудника..."
                                value={searchTerm}
                                onChange={e => setSearchTerm(e.target.value)}
                                className="w-full pl-9 pr-4 py-2 border border-slate-200 rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none"
                                autoFocus
                            />
                        </div>
                        <div className="flex-1 overflow-y-auto border border-slate-100 rounded-lg bg-slate-50">
                            {filteredWorkers.map(w => {
                                const busyLocation = workerLocations[w.name];
                                return (
                                    <button
                                        key={w.name}
                                        onClick={() => handleAdd(w.name)}
                                        className="w-full text-left px-4 py-2 hover:bg-white hover:shadow-sm border-b border-slate-100 last:border-0 transition-all flex justify-between items-center group"
                                    >
                                        <div className="flex-1 min-w-0 pr-2">
                                            <div className="font-semibold text-slate-700 text-sm truncate">{w.name}</div>
                                            <div className="text-xs text-slate-400 flex flex-wrap gap-2 items-center">
                                                {w.role && <span>{w.role}</span>}
                                                {busyLocation ? (
                                                    <span className="text-orange-600 bg-orange-50 px-1.5 rounded flex items-center gap-1 font-medium truncate max-w-full" title={`Перенести с: ${busyLocation.line} (Смена ${busyLocation.shift})`}>
                                                        <ArrowRightLeft size={10} /> Перенести с: {busyLocation.line} ({busyLocation.shift})
                                                    </span>
                                                ) : (
                                                    w.homeLine ? <span className="text-slate-400">{w.homeLine}</span> : <span className="text-green-600 font-medium">Не распределен</span>
                                                )}
                                            </div>
                                        </div>
                                        <Plus size={16} className={`flex-shrink-0 group-hover:text-blue-500 ${busyLocation ? 'text-orange-300' : 'text-slate-300'}`} />
                                    </button>
                                );
                            })}
                            {searchTerm && filteredWorkers.length === 0 && (
                                <button
                                    onClick={handleCreateNew}
                                    className="w-full text-left px-4 py-3 text-blue-600 hover:bg-blue-50 font-medium text-sm flex items-center gap-2"
                                >
                                    <Plus size={16} /> Создать нового: "{searchTerm}"
                                </button>
                            )}
                        </div>
                    </div>
                </div>

                <div className="bg-slate-50 px-6 py-4 border-t border-slate-200 flex justify-end rounded-b-2xl">
                    <button onClick={handleSaveInternal} className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg transition-colors shadow-sm flex items-center gap-2">
                        <CheckCircle2 size={18} /> Сохранить
                    </button>
                </div>
            </div>
        </div>
    );
};

const UpdateReportModal = ({ data, onClose }) => {
    if (!data) return null;
    const { savedDays, savedAssignmentsCount, changedDays } = data;
    return (
        <div className="fixed inset-0 bg-slate-900/50 backdrop-blur-sm z-50 flex items-center justify-center p-4 animate-in fade-in duration-200">
            <div className="bg-white rounded-2xl shadow-2xl max-w-md w-full overflow-hidden border border-slate-200">
                <div className="bg-slate-50 px-6 py-4 border-b border-slate-100 flex items-center gap-3">
                    <div className="bg-green-100 p-2 rounded-full text-green-600"><CheckCircle2 size={24} /></div>
                    <h3 className="font-bold text-lg text-slate-800">План обновлен</h3>
                </div>
                <div className="p-6 space-y-6">
                    <div className="bg-green-50 border border-green-100 rounded-xl p-4">
                        <h4 className="font-bold text-green-800 mb-2 flex items-center gap-2">📊 Сохранено</h4>
                        <ul className="space-y-1 text-sm text-green-700 font-medium">
                            <li className="flex items-center gap-2"><div className="w-1.5 h-1.5 rounded-full bg-green-500"></div> {savedDays} дней без изменений</li>
                            <li className="flex items-center gap-2"><div className="w-1.5 h-1.5 rounded-full bg-green-500"></div> {savedAssignmentsCount} ручных назначений</li>
                        </ul>
                    </div>
                    {changedDays.length > 0 ? (
                        <div className="bg-amber-50 border border-amber-100 rounded-xl p-4">
                            <h4 className="font-bold text-amber-800 mb-2 flex items-center gap-2"><AlertTriangle size={18} /> Требуют проверки ({changedDays.length})</h4>
                            <div className="max-h-40 overflow-y-auto pr-2 space-y-2">
                                {changedDays.map((day, idx) => (
                                    <div key={idx} className="text-xs bg-white border border-amber-200 p-2 rounded text-amber-900 flex justify-between"><span className="font-bold">{day.date}</span><span>Бригада {day.shift}</span></div>
                                ))}
                            </div>
                        </div>
                    ) : (<div className="text-center text-slate-400 text-sm">Все дни совпали со старым планом</div>)}
                </div>
                <div className="bg-slate-50 px-6 py-4 border-t border-slate-200 flex justify-end">
                    <button onClick={onClose} className="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-6 rounded-lg transition-colors shadow-sm">Понятно</button>
                </div>
            </div>
        </div>
    );
};

const RvPickerModal = ({ isOpen, onClose, slotData, lineTemplates, workerRegistry, globalSchedule, scheduleDates, currentShiftId, onAssign }) => {
    const [showAll, setShowAll] = useState(false);

    if (!isOpen || !slotData) return null;

    const { date, roleTitle, slotId, currentShiftType } = slotData;
    const { prev, next } = getRealNeighborDateStrings(date);
    const isTargetNight = currentShiftType.toLowerCase().includes('ночь');

    const candidates = [];
    const processedNames = new Set();

    let countTotal = 0;
    let countRole = 0;
    let countAvail = 0;
    let countWork = 0;

    Object.keys(lineTemplates).forEach(lineKey => {
        lineTemplates[lineKey].forEach(pos => {
            Object.entries(pos.roster).forEach(([bId, namesStr]) => {
                const names = namesStr.split(/[,;\n/]+/).map(s => s.trim()).filter(s => s.length > 1);
                names.forEach(name => {
                    if (processedNames.has(name)) return;
                    processedNames.add(name);
                    countTotal++;

                    const reg = workerRegistry[name];

                    const r1 = pos.role.toLowerCase();
                    const r2 = roleTitle.toLowerCase();
                    const hasRole = r1.includes(r2) || r2.includes(r1);
                    const hasComp = reg && Array.from(reg.competencies).some(c => c.toLowerCase().includes(r2));

                    if (!showAll && !hasRole && !hasComp) return;
                    countRole++;

                    const avail = checkWorkerAvailability(name, date, workerRegistry);
                    if (!avail.available) return;
                    countAvail++;

                    const todayShiftMap = globalSchedule[date];
                    const todayShift = todayShiftMap ? todayShiftMap.get(name) : undefined;

                    const nextShiftMap = globalSchedule[next];
                    const nextShift = nextShiftMap ? nextShiftMap.get(name) : undefined;

                    const prevShiftMap = globalSchedule[prev];
                    const prevShift = prevShiftMap ? prevShiftMap.get(name) : undefined;

                    let isBlocked = false;

                    if (todayShift) isBlocked = true;

                    if (!isBlocked) {
                        if (isTargetNight) {
                            if (nextShift && nextShift.includes('Day')) isBlocked = true;
                        } else {
                            if (prevShift && prevShift.includes('Night')) isBlocked = true;
                        }
                    }

                    if (!isBlocked) {
                        candidates.push({
                            name,
                            mainRole: pos.role,
                            homeLine: lineKey,
                            sourceShift: bId,
                            isComp: hasComp && !hasRole
                        });
                    } else {
                        countWork++;
                    }
                });
            });
        });
    });

    candidates.sort((a, b) => {
        if (a.isComp !== b.isComp) return a.isComp ? 1 : -1;
        return a.name.localeCompare(b.name);
    });

    return (
        <div className="fixed inset-0 bg-slate-900/50 backdrop-blur-sm z-50 flex items-center justify-center p-4 animate-in fade-in duration-200">
            <div className="bg-white rounded-2xl shadow-xl w-full max-w-lg overflow-hidden flex flex-col max-h-[80vh]">
                <div className="bg-orange-50 px-6 py-4 border-b border-orange-100 flex justify-between items-center">
                    <div>
                        <h3 className="font-bold text-lg text-orange-800 flex items-center gap-2"><UserPlus size={20} /> Назначить РВ</h3>
                        <div className="text-xs text-orange-600 mt-1 flex gap-2">
                            <span>Найдено: {candidates.length}</span>
                            <span className="opacity-50">| Всего: {countTotal} | Роль: {countRole} | Доступны: {countAvail}</span>
                        </div>
                    </div>
                    <button onClick={onClose} className="text-orange-400 hover:text-orange-600"><X size={20} /></button>
                </div>

                <div className="p-4 bg-slate-50 border-b border-slate-200 text-sm text-slate-600">
                    <div className="flex justify-between items-start mb-2">
                        <div>
                            <div>Вакансия: <span className="font-bold text-slate-800">{roleTitle}</span></div>
                            <div className="flex items-center gap-2">
                                Дата: <span className="font-bold text-slate-800">{date}</span>
                                <span className={`text-[10px] px-1.5 py-0.5 rounded ${isTargetNight ? 'bg-blue-100 text-blue-700' : 'bg-yellow-100 text-yellow-700'}`}>
                                    {isTargetNight ? 'НОЧЬ' : 'ДЕНЬ'}
                                </span>
                            </div>
                        </div>
                        <button
                            onClick={() => setShowAll(!showAll)}
                            className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-xs font-bold transition-colors ${showAll ? 'bg-blue-100 text-blue-700' : 'bg-slate-200 text-slate-600 hover:bg-slate-300'}`}
                        >
                            {showAll ? <ToggleRight size={16} /> : <ToggleLeft size={16} />}
                            Все сотрудники
                        </button>
                    </div>
                </div>

                <div className="flex-1 overflow-y-auto p-4 space-y-2">
                    {candidates.length === 0 ? (
                        <div className="text-center py-10 text-slate-400">
                            <Ban size={32} className="mx-auto mb-2 opacity-50" />
                            Нет доступных кандидатов<br />
                            <span className="text-xs">
                                {countWork > 0 ? "Сотрудники уже работают или отдыхают" : "Нет подходящих по роли или в отпуске"}
                            </span>
                        </div>
                    ) : (
                        candidates.map((worker, i) => (
                            <button
                                key={i}
                                onClick={() => onAssign(worker, slotId)}
                                className="w-full bg-white border border-slate-200 hover:border-orange-300 hover:bg-orange-50 p-3 rounded-xl flex items-center justify-between group transition-all text-left"
                            >
                                <div>
                                    <div className="font-bold text-slate-700">{worker.name}</div>
                                    <div className="text-xs text-slate-500 flex items-center gap-2">
                                        Бригада {worker.sourceShift} • {worker.mainRole}
                                        {worker.isComp && <span className="bg-blue-100 text-blue-600 px-1.5 rounded text-[10px] flex items-center gap-1"><GraduationCap size={10} /> Компетенция</span>}
                                    </div>
                                </div>
                                <div className="text-orange-500 opacity-0 group-hover:opacity-100 transition-opacity font-bold text-sm">
                                    Выбрать
                                </div>
                            </button>
                        ))
                    )}
                </div>
            </div>
        </div>
    );
};

const CustomDateSelector = ({ dates, selectedDate, onSelect, getStatsByDate }) => {
    const [isOpen, setIsOpen] = useState(false);
    const containerRef = useRef(null);

    useEffect(() => {
        const handleClickOutside = (event) => { if (containerRef.current && !containerRef.current.contains(event.target)) setIsOpen(false); };
        document.addEventListener('mousedown', handleClickOutside);
        return () => document.removeEventListener('mousedown', handleClickOutside);
    }, []);

    const getStatusColor = (date) => {
        if (!getStatsByDate) return 'bg-slate-100 text-slate-500';
        const stats = getStatsByDate(date);
        if (!stats) return 'bg-slate-100 text-slate-500';
        if (stats.status === 'complete') return 'bg-emerald-500 text-white';
        if (stats.status === 'warning') return 'bg-amber-500 text-white';
        if (stats.status === 'critical') return 'bg-red-500 text-white';
        return 'bg-slate-100 text-slate-500';
    };

    const getBorderClass = (date) => {
        if (!getStatsByDate) return '';
        const stats = getStatsByDate(date);
        if (stats && stats.manualEdits > 0) return 'ring-2 ring-blue-500 ring-offset-1';
        return '';
    };

    const selectedStats = getStatsByDate ? getStatsByDate(selectedDate) : null;

    return (
        <div className="relative w-64" ref={containerRef}>
            <button onClick={() => setIsOpen(!isOpen)} className="w-full bg-white border border-slate-200 hover:border-blue-400 text-slate-700 font-semibold py-2 pl-3 pr-10 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm transition-all flex items-center justify-between shadow-sm">
                <div className="flex items-center gap-2">
                    <span>{selectedDate || 'Выберите дату'}</span>
                    {selectedStats && (
                        <div className="flex items-center gap-1 ml-1 opacity-90">
                            {selectedStats.vacancies > 0 ? (
                                <span className="bg-red-100 text-red-600 text-[10px] px-1.5 py-0.5 rounded font-bold flex items-center gap-0.5"><AlertTriangle size={10} /> {selectedStats.vacancies}</span>
                            ) : (<span className="bg-green-100 text-green-600 text-[10px] px-1.5 py-0.5 rounded font-bold"><CheckCircle2 size={10} /></span>)}
                            {selectedStats.freeStaff > 0 && (<span className="bg-slate-100 text-slate-600 text-[10px] px-1.5 py-0.5 rounded font-bold flex items-center gap-0.5"><Users size={10} /> {selectedStats.freeStaff}</span>)}
                        </div>
                    )}
                </div>
                {isOpen ? <ChevronUp size={16} className="text-slate-400" /> : <ChevronDown size={16} className="text-slate-400" />}
            </button>

            {isOpen && (
                <div className="absolute top-full left-0 mt-2 w-full max-h-80 overflow-y-auto bg-white rounded-xl shadow-xl border border-slate-200 z-50 py-2">
                    {dates.map(date => {
                        const stats = (getStatsByDate && getStatsByDate(date)) || { vacancies: 0, freeStaff: 0 };
                        const colorClass = getStatusColor(date);
                        const borderClass = getBorderClass(date);
                        return (
                            <div key={date} onClick={() => { onSelect(date); setIsOpen(false); }} className={`px-3 py-2 hover:bg-slate-50 cursor-pointer flex items-center justify-between group transition-colors ${selectedDate === date ? 'bg-blue-50' : ''}`}>
                                <div className="flex items-center gap-3"><div className={`w-2 h-2 rounded-full ${colorClass === 'bg-slate-100 text-slate-500' ? 'bg-slate-300' : colorClass.split(' ')[0]}`}></div><span className={`text-sm font-medium ${selectedDate === date ? 'text-blue-700' : 'text-slate-700'}`}>{date}</span></div>
                                <div className="flex items-center gap-2">
                                    {getBorderClass(date) && <Edit3 size={12} className="text-blue-500" />}
                                    <div className="flex items-center gap-1 bg-slate-100 text-slate-600 px-1.5 py-0.5 rounded text-[10px] font-bold min-w-[35px] justify-center" title="Свободные штатные"><Users size={10} />{stats.freeStaff}</div>
                                    <div className={`px-1.5 py-0.5 rounded text-[10px] font-bold min-w-[20px] text-center ${colorClass} ${borderClass}`} title="Вакансии">{stats.vacancies}</div>
                                </div>
                            </div>
                        );
                    })}
                </div>
            )}
        </div>
    );
};

const DayStatusHeader = ({ stats, date }) => {
    if (!stats) return null;
    return (
        <div className="bg-white rounded-xl border border-slate-200 shadow-sm p-4 mb-6 grid grid-cols-1 md:grid-cols-4 gap-4 animate-in fade-in slide-in-from-top-4 duration-300">
            <div className="flex items-center gap-3 border-r border-slate-100 pr-4"><div className="bg-slate-100 p-2 rounded-lg text-slate-600"><Briefcase size={20} /></div><div><div className="text-xs text-slate-500 font-medium">Всего мест</div><div className="text-lg font-bold text-slate-800">{stats.totalSlots}</div></div></div>
            <div className="flex items-center gap-3 border-r border-slate-100 pr-4"><div className={`p-2 rounded-lg ${stats.vacancies > 0 ? 'bg-red-100 text-red-600' : 'bg-green-100 text-green-600'}`}><AlertTriangle size={20} /></div><div><div className="text-xs text-slate-500 font-medium">Вакансии</div><div className={`text-lg font-bold ${stats.vacancies > 0 ? 'text-red-600' : 'text-green-600'}`}>{stats.vacancies} <span className="text-xs text-slate-400 font-normal">({Math.round((stats.vacancies / stats.totalSlots) * 100 || 0)}%)</span></div></div></div>
            <div className="flex items-center gap-3 border-r border-slate-100 pr-4"><div className="bg-blue-100 p-2 rounded-lg text-blue-600"><Users size={20} /></div><div><div className="text-xs text-slate-500 font-medium">Ресурс</div><div className="text-sm font-bold text-slate-700">{stats.freeStaff} <span className="text-slate-400 font-normal">штат</span> + {stats.floatersAvailable} <span className="text-slate-400 font-normal">резерв</span></div></div></div>
            <div className="flex items-center gap-3"><div className="bg-indigo-100 p-2 rounded-lg text-indigo-600"><Edit3 size={20} /></div><div><div className="text-xs text-slate-500 font-medium">Ручные правки</div><div className="text-lg font-bold text-indigo-600">{stats.manualEdits}</div></div></div>
        </div>
    );
};

const EditWorkerModal = ({ worker, onClose, onSave, onDelete, workerRegistry, lineTemplates }) => {
    const [name, setName] = useState(worker ? worker.name : '');
    const [statusType, setStatusType] = useState(worker?.status?.type || 'active');
    const [dateFrom, setDateFrom] = useState('');
    const [dateTo, setDateTo] = useState('');
    const [selectedCompetencies, setSelectedCompetencies] = useState(
        worker && worker.competencies ? Array.from(worker.competencies) : []
    );
    const [compInput, setCompInput] = useState('');
    const [showCompDropdown, setShowCompDropdown] = useState(false);

    const allCompetencies = useMemo(() => {
        const set = new Set();

        Object.values(workerRegistry).forEach(w => {
            if (w.competencies) {
                w.competencies.forEach(c => set.add(c));
            }
        });

        if (lineTemplates) {
            Object.values(lineTemplates).forEach(positions => {
                positions.forEach(pos => {
                    if (pos.role) {
                        const roleName = pos.role.trim();
                        if (roleName) set.add(roleName);
                    }
                });
            });
        }

        return Array.from(set).sort();
    }, [workerRegistry, lineTemplates]);

    const filteredComps = allCompetencies.filter(c =>
        c.toLowerCase().includes(compInput.toLowerCase()) &&
        !selectedCompetencies.includes(c)
    );

    useEffect(() => {
        if (worker && worker.status && !worker.status.permanent) {
            const fmt = (d) => d ? d.toISOString().split('T')[0] : '';
            setDateFrom(fmt(worker.status.from));
            setDateTo(fmt(worker.status.to));
        }
    }, [worker]);

    const addCompetency = (comp) => {
        if (!selectedCompetencies.includes(comp)) {
            setSelectedCompetencies([...selectedCompetencies, comp]);
        }
        setCompInput('');
        setShowCompDropdown(false);
    };

    const removeCompetency = (compToRemove) => {
        setSelectedCompetencies(selectedCompetencies.filter(c => c !== compToRemove));
    };

    const handleSave = () => {
        if (!name.trim()) return;
        const compSet = new Set(selectedCompetencies);
        let newStatus = null;
        if (statusType !== 'active') {
            if (statusType === 'fired') {
                newStatus = { type: 'fired', raw: 'Уволен', permanent: true };
            } else if (dateFrom && dateTo) {
                const d1 = new Date(dateFrom);
                const d2 = new Date(dateTo);
                const raw = `${statusType === 'vacation' ? 'Отпуск' : 'Больничный'} ${d1.getDate()}.${d1.getMonth() + 1}-${d2.getDate()}.${d2.getMonth() + 1}`;
                newStatus = { type: statusType, from: d1, to: d2, raw, permanent: false };
            }
        }
        onSave({
            oldName: worker ? worker.name : null,
            newName: name.trim(),
            competencies: compSet,
            status: newStatus
        });
        onClose();
    };

    return (
        <div className="fixed inset-0 bg-slate-900/50 backdrop-blur-sm z-50 flex items-center justify-center p-4">
            <div className="bg-white rounded-2xl shadow-xl w-full max-w-md overflow-visible flex flex-col max-h-[90vh]">
                <div className="bg-slate-50 px-6 py-4 border-b border-slate-100 flex justify-between items-center rounded-t-2xl">
                    <h3 className="font-bold text-lg text-slate-800">{worker ? 'Редактировать сотрудника' : 'Новый сотрудник'}</h3>
                    <button onClick={onClose}><X size={20} className="text-slate-400 hover:text-slate-600" /></button>
                </div>
                <div className="p-6 space-y-4 overflow-y-auto">
                    <div>
                        <label className="block text-xs font-bold text-slate-500 uppercase mb-1">ФИО</label>
                        <input type="text" value={name} onChange={e => setName(e.target.value)} className="w-full border border-slate-300 rounded-lg p-2 text-sm focus:ring-2 focus:ring-blue-500 outline-none" />
                    </div>

                    <div className="relative">
                        <label className="block text-xs font-bold text-slate-500 uppercase mb-1">Компетенции</label>
                        <div className="border border-slate-300 rounded-lg p-2 bg-white min-h-[42px] flex flex-wrap gap-2 items-center focus-within:ring-2 focus-within:ring-blue-500 focus-within:border-transparent">
                            {selectedCompetencies.map(comp => (
                                <span key={comp} className="bg-blue-100 text-blue-700 px-2 py-1 rounded text-xs font-bold flex items-center gap-1">
                                    {comp}
                                    <button onClick={() => removeCompetency(comp)} className="hover:text-blue-900"><X size={12} /></button>
                                </span>
                            ))}
                            <input
                                type="text"
                                value={compInput}
                                onChange={(e) => { setCompInput(e.target.value); setShowCompDropdown(true); }}
                                onFocus={() => setShowCompDropdown(true)}
                                onKeyDown={(e) => {
                                    if (e.key === 'Enter' && compInput.trim()) {
                                        e.preventDefault();
                                        addCompetency(compInput.trim());
                                    }
                                }}
                                className="flex-1 min-w-[100px] outline-none text-sm bg-transparent"
                                placeholder={selectedCompetencies.length === 0 ? "Выберите или введите..." : ""}
                            />
                        </div>

                        {showCompDropdown && compInput.length >= 0 && (
                            <div className="absolute top-full left-0 right-0 mt-1 bg-white border border-slate-200 rounded-lg shadow-xl max-h-48 overflow-y-auto z-50">
                                {filteredComps.length > 0 ? (
                                    filteredComps.map(comp => (
                                        <div
                                            key={comp}
                                            onClick={() => addCompetency(comp)}
                                            className="px-3 py-2 hover:bg-blue-50 cursor-pointer text-sm text-slate-700 flex items-center justify-between group"
                                        >
                                            {comp}
                                            <Plus size={14} className="opacity-0 group-hover:opacity-100 text-blue-500" />
                                        </div>
                                    ))
                                ) : (
                                    compInput.trim() && (
                                        <div
                                            onClick={() => addCompetency(compInput.trim())}
                                            className="px-3 py-2 hover:bg-green-50 cursor-pointer text-sm text-green-700 font-medium"
                                        >
                                            Добавить "{compInput}"
                                        </div>
                                    )
                                )}
                                {filteredComps.length === 0 && !compInput.trim() && (
                                    <div className="px-3 py-2 text-xs text-slate-400 italic">Нет доступных компетенций</div>
                                )}
                            </div>
                        )}
                        {showCompDropdown && (<div className="fixed inset-0 z-40" onClick={() => setShowCompDropdown(false)}></div>)}
                    </div>

                    <div className="bg-slate-50 p-3 rounded-lg border border-slate-200">
                        <label className="block text-xs font-bold text-slate-500 uppercase mb-2">Статус</label>
                        <div className="flex gap-2 mb-3">
                            {['active', 'vacation', 'sick', 'fired'].map(t => (
                                <button key={t} onClick={() => setStatusType(t)} className={`flex-1 py-1.5 text-xs font-bold rounded capitalize border ${statusType === t ? 'bg-blue-600 text-white border-blue-600' : 'bg-white text-slate-600 border-slate-300 hover:bg-slate-100'}`}>
                                    {t === 'active' ? 'Работает' : (t === 'vacation' ? 'Отпуск' : (t === 'sick' ? 'Болеет' : 'Уволен'))}
                                </button>
                            ))}
                        </div>
                        {(statusType === 'vacation' || statusType === 'sick') && (
                            <div className="flex gap-2">
                                <input type="date" value={dateFrom} onChange={e => setDateFrom(e.target.value)} className="flex-1 border border-slate-300 rounded p-1 text-xs" />
                                <span className="text-slate-400 self-center">-</span>
                                <input type="date" value={dateTo} onChange={e => setDateTo(e.target.value)} className="flex-1 border border-slate-300 rounded p-1 text-xs" />
                            </div>
                        )}
                    </div>
                </div>
                <div className="bg-slate-50 px-6 py-4 border-t border-slate-200 flex justify-between rounded-b-2xl">
                    {worker ? (
                        <button onClick={() => { if (confirm('Удалить сотрудника?')) { onDelete(worker.name); onClose(); } }} className="text-red-500 hover:text-red-700 text-sm font-semibold flex items-center gap-1"><Trash2 size={16} /> Удалить</button>
                    ) : <div></div>}
                    <button onClick={handleSave} className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg transition-colors">Сохранить</button>
                </div>
            </div>
        </div>
    );
};

const DistributionView = ({ lineTemplates, workerRegistry, floaters, onMatrixUpdate }) => {
    const [filter, setFilter] = useState('');
    const [editingCell, setEditingCell] = useState(null);

    const handleCellClick = (lineName, pIdx, shiftId, currentNames, role) => {
        setEditingCell({ lineName, pIdx, shiftId, currentNames, role });
    };

    const handleModalSave = (newNamesList) => {
        if (editingCell) {
            onMatrixUpdate(editingCell.lineName, editingCell.pIdx, editingCell.shiftId, newNamesList);
        }
    };

    const renderCellContent = (namesStr) => {
        if (!namesStr) return <span className="text-slate-300 italic text-[10px]">Пусто</span>;
        const names = namesStr.split(/[,;\n/]+/).map(s => s.trim()).filter(s => s.length > 1);

        return (
            <div className="flex flex-col gap-1">
                {names.map((name, i) => {
                    const reg = workerRegistry[name];
                    const status = reg?.status;
                    let statusColor = 'bg-slate-50 border-slate-200 text-slate-700';
                    if (status) {
                        if (status.type === 'vacation') statusColor = 'bg-emerald-50 border-emerald-200 text-emerald-700';
                        else if (status.type === 'sick') statusColor = 'bg-amber-50 border-amber-200 text-amber-700';
                        else if (status.type === 'fired') statusColor = 'bg-red-50 border-red-200 text-red-700 line-through decoration-red-400';
                    }

                    return (
                        <div key={i} className={`text-xs px-2 py-1.5 rounded border ${statusColor} flex flex-col`}>
                            <div className="font-semibold flex justify-between items-center">
                                {name}
                                {reg?.competencies.size > 0 && <GraduationCap size={12} className="text-blue-400" />}
                            </div>
                            {status && !status.permanent && (
                                <div className="text-[10px] opacity-75">{status.raw}</div>
                            )}
                            {reg?.competencies.size > 0 && (
                                <div className="text-[9px] text-slate-400 mt-0.5 truncate max-w-[150px]">
                                    {Array.from(reg.competencies).join(', ')}
                                </div>
                            )}
                        </div>
                    );
                })}
            </div>
        );
    };

    return (
        <div className="h-full flex flex-col bg-white rounded-xl shadow-sm border border-slate-200 overflow-hidden relative">
            <MatrixAssignmentModal
                isOpen={!!editingCell}
                onClose={() => setEditingCell(null)}
                context={editingCell}
                currentNames={editingCell?.currentNames}
                workerRegistry={workerRegistry}
                lineTemplates={lineTemplates} // Pass lineTemplates for validation
                onSave={handleModalSave}
            />

            <div className="p-4 border-b bg-slate-50 flex justify-between items-center flex-shrink-0">
                <div className="flex items-center gap-2 font-bold text-slate-700">
                    <LayoutGrid size={20} className="text-blue-600" />
                    Матрица распределения (Люд)
                </div>
                <div className="flex items-center gap-4">
                    <div className="text-xs text-slate-400 italic flex items-center gap-1">
                        <Edit3 size={12} /> Кликните на ячейку для редактирования
                    </div>
                    <div className="relative">
                        <Search size={14} className="absolute left-3 top-1/2 -translate-y-1/2 text-slate-400 pointer-events-none" />
                        <input type="text" placeholder="Поиск..." value={filter} onChange={(e) => setFilter(e.target.value)} className="pl-9 pr-4 py-1.5 bg-white border border-slate-200 rounded-lg text-sm text-slate-700 focus:ring-2 focus:ring-blue-500 outline-none w-64" />
                    </div>
                </div>
            </div>
            <div className="overflow-auto flex-1 p-0">
                <table className="w-full text-sm text-left border-collapse">
                    <thead className="bg-slate-100 text-slate-600 font-semibold sticky top-0 z-10 shadow-sm">
                        <tr>
                            <th className="px-4 py-3 border-r border-b border-slate-200 w-40">Линия</th>
                            <th className="px-4 py-3 border-r border-b border-slate-200 w-48">Должность</th>
                            <th className="px-2 py-3 border-r border-b border-slate-200 w-16 text-center">Норма</th>
                            <th className="px-4 py-3 border-r border-b border-slate-200 min-w-[200px] bg-blue-50/50">Смена 1</th>
                            <th className="px-4 py-3 border-r border-b border-slate-200 min-w-[200px] bg-indigo-50/50">Смена 2</th>
                            <th className="px-4 py-3 border-r border-b border-slate-200 min-w-[200px] bg-blue-50/50">Смена 3</th>
                            <th className="px-4 py-3 border-b border-slate-200 min-w-[200px] bg-indigo-50/50">Смена 4</th>
                        </tr>
                    </thead>
                    <tbody className="divide-y divide-slate-100">
                        {Object.entries(lineTemplates).map(([lineName, positions], idx) => {
                            if (filter && !lineName.toLowerCase().includes(filter.toLowerCase()) && !positions.some(p => Object.values(p.roster).some(n => n.toLowerCase().includes(filter.toLowerCase())))) return null;

                            return positions.map((pos, pIdx) => (
                                <tr key={`${idx}-${pIdx}`} className="hover:bg-slate-50 transition-colors">
                                    {pIdx === 0 && (
                                        <td rowSpan={positions.length} className="px-4 py-3 font-bold text-slate-700 border-r border-slate-200 bg-white align-top sticky left-0">{lineName}</td>
                                    )}
                                    <td className="px-4 py-3 text-slate-600 border-r border-slate-200 font-medium">{pos.role}</td>
                                    <td className="px-2 py-3 text-center text-slate-500 border-r border-slate-200">{pos.count}</td>
                                    {['1', '2', '3', '4'].map(shiftId => (
                                        <td
                                            key={shiftId}
                                            onClick={() => handleCellClick(lineName, pIdx, shiftId, pos.roster[shiftId], pos.role)}
                                            className={`px-2 py-2 border-r border-slate-200 align-top cursor-pointer hover:bg-black/5 transition-colors group relative ${shiftId % 2 !== 0 ? 'bg-blue-50/10' : 'bg-indigo-50/10'}`}
                                        >
                                            <div className="absolute top-1 right-1 opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none">
                                                <Edit3 size={12} className="text-slate-400" />
                                            </div>
                                            {renderCellContent(pos.roster[shiftId])}
                                        </td>
                                    ))}
                                </tr>
                            ));
                        })}
                        <tr className="bg-yellow-50/50 border-t-2 border-slate-200">
                            <td colSpan={7} className="px-4 py-2 font-bold text-slate-700 text-center uppercase tracking-wide text-xs">Плавающий состав (Резерв)</td>
                        </tr>
                        <tr>
                            <td className="px-4 py-3 font-bold text-slate-700 border-r border-slate-200 align-top">Резерв День</td>
                            <td className="px-4 py-3 text-slate-600 border-r border-slate-200">Подсобник</td>
                            <td className="px-2 py-3 text-center text-slate-500 border-r border-slate-200">-</td>
                            <td colSpan={4} className="px-2 py-2 align-top">
                                <div className="grid grid-cols-2 md:grid-cols-4 gap-2">
                                    {floaters.day.map((f, i) => (
                                        <div key={i} className="bg-white border border-yellow-200 rounded p-2 text-xs shadow-sm">
                                            <div className="font-bold text-slate-700">{f.name}</div>
                                            {workerRegistry[f.name]?.status && <div className="text-[10px] text-red-500">{workerRegistry[f.name].status.raw}</div>}
                                        </div>
                                    ))}
                                </div>
                            </td>
                        </tr>
                        <tr>
                            <td className="px-4 py-3 font-bold text-slate-700 border-r border-slate-200 align-top">Резерв Ночь</td>
                            <td className="px-4 py-3 text-slate-600 border-r border-slate-200">Подсобник</td>
                            <td className="px-2 py-3 text-center text-slate-500 border-r border-slate-200">-</td>
                            <td colSpan={4} className="px-2 py-2 align-top">
                                <div className="grid grid-cols-2 md:grid-cols-4 gap-2">
                                    {floaters.night.map((f, i) => (
                                        <div key={i} className="bg-slate-800 border border-slate-700 rounded p-2 text-xs shadow-sm">
                                            <div className="font-bold text-slate-200">{f.name}</div>
                                            {workerRegistry[f.name]?.status && <div className="text-[10px] text-red-300">{workerRegistry[f.name].status.raw}</div>}
                                        </div>
                                    ))}
                                </div>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    );
};

const EmployeeListView = ({ workerRegistry, onEditWorker, onAddWorker }) => {
    const [search, setSearch] = useState('');
    const [sortConfig, setSortConfig] = useState({ key: 'name', direction: 'asc' });

    const [showFilters, setShowFilters] = useState(false);
    const [roleFilter, setRoleFilter] = useState('');
    const [lineFilter, setLineFilter] = useState('');
    const [statusFilter, setStatusFilter] = useState('');
    const [compFilter, setCompFilter] = useState('');

    const { uniqueRoles, uniqueLines } = useMemo(() => {
        const roles = new Set();
        const lines = new Set();
        Object.values(workerRegistry).forEach(w => {
            if (w.role) roles.add(w.role);
            if (w.homeLine) lines.add(w.homeLine);
        });
        return {
            uniqueRoles: Array.from(roles).sort(),
            uniqueLines: Array.from(lines).sort()
        };
    }, [workerRegistry]);

    const handleSort = (key) => {
        let direction = 'asc';
        if (sortConfig.key === key && sortConfig.direction === 'asc') {
            direction = 'desc';
        }
        setSortConfig({ key, direction });
    };

    const sortedWorkers = useMemo(() => {
        let items = Object.values(workerRegistry);
        if (sortConfig.key) {
            items.sort((a, b) => {
                let aValue, bValue;

                if (sortConfig.key === 'role') {
                    aValue = `${a.role || ''} ${a.homeLine || ''}`.toLowerCase();
                    bValue = `${b.role || ''} ${b.homeLine || ''}`.toLowerCase();
                } else if (sortConfig.key === 'status') {
                    const getRank = (s) => !s ? 0 : (s.type === 'vacation' ? 1 : (s.type === 'sick' ? 2 : 3));
                    aValue = getRank(a.status);
                    bValue = getRank(b.status);
                } else if (sortConfig.key === 'competencies') {
                    aValue = a.competencies ? a.competencies.size : 0;
                    bValue = b.competencies ? b.competencies.size : 0;
                } else {
                    aValue = String(a[sortConfig.key] || '').toLowerCase();
                    bValue = String(b[sortConfig.key] || '').toLowerCase();
                }

                if (aValue < bValue) return sortConfig.direction === 'asc' ? -1 : 1;
                if (aValue > bValue) return sortConfig.direction === 'asc' ? 1 : -1;
                return 0;
            });
        }
        return items;
    }, [workerRegistry, sortConfig]);

    const filteredWorkers = sortedWorkers.filter(w => {
        if (search && !w.name.toLowerCase().includes(search.toLowerCase())) return false;

        if (roleFilter && w.role !== roleFilter) return false;

        if (lineFilter && w.homeLine !== lineFilter) return false;

        if (statusFilter) {
            if (statusFilter === 'active') {
                if (w.status && !w.status.permanent && (w.status.type === 'vacation' || w.status.type === 'sick')) return false;
                if (w.status?.type === 'fired') return false;
            } else {
                if (w.status?.type !== statusFilter) return false;
            }
        }

        if (compFilter) {
            const hasComp = Array.from(w.competencies || []).some(c => c.toLowerCase().includes(compFilter.toLowerCase()));
            if (!hasComp) return false;
        }

        return true;
    });

    const activeFiltersCount = [roleFilter, lineFilter, statusFilter, compFilter].filter(Boolean).length;

    const clearFilters = () => {
        setRoleFilter('');
        setLineFilter('');
        setStatusFilter('');
        setCompFilter('');
        setSearch('');
    };

    const SortHeader = ({ label, sortKey, className = "" }) => (
        <th
            className={`px-6 py-3 border-b cursor-pointer hover:bg-slate-200 transition-colors group select-none ${className}`}
            onClick={() => handleSort(sortKey)}
        >
            <div className="flex items-center gap-1">
                {label}
                <div className={`text-slate-400 transition-opacity ${sortConfig.key === sortKey ? 'opacity-100 text-blue-600' : 'opacity-0 group-hover:opacity-50'}`}>
                    {sortConfig.key === sortKey && sortConfig.direction === 'desc' ? <ChevronDown size={14} /> : (sortConfig.key === sortKey ? <ChevronUp size={14} /> : <ArrowUpDown size={14} />)}
                </div>
            </div>
        </th>
    );

    return (
        <div className="h-full flex flex-col bg-white rounded-xl shadow-sm border border-slate-200 overflow-hidden">
            <div className="p-4 border-b bg-slate-50 flex flex-col gap-4 flex-shrink-0">
                <div className="flex justify-between items-center">
                    <div className="flex items-center gap-2 font-bold text-slate-700">
                        <Users size={20} className="text-blue-600" />
                        База сотрудников
                        <span className="bg-slate-100 text-slate-500 text-xs px-2 py-0.5 rounded-full">{filteredWorkers.length}</span>
                    </div>
                    <div className="flex items-center gap-3">
                        <div className="relative">
                            <Search size={14} className="absolute left-3 top-1/2 -translate-y-1/2 text-slate-400 pointer-events-none" />
                            <input type="text" placeholder="Быстрый поиск..." value={search} onChange={(e) => setSearch(e.target.value)} className="pl-9 pr-4 py-1.5 bg-white border border-slate-200 rounded-lg text-sm text-slate-700 focus:ring-2 focus:ring-blue-500 outline-none w-64" />
                        </div>
                        <button
                            onClick={() => setShowFilters(!showFilters)}
                            className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-xs font-bold transition-colors border ${showFilters || activeFiltersCount > 0 ? 'bg-blue-50 border-blue-200 text-blue-700' : 'bg-white border-slate-200 text-slate-600 hover:bg-slate-50'}`}
                        >
                            <SlidersHorizontal size={16} />
                            Фильтры
                            {activeFiltersCount > 0 && <span className="bg-blue-600 text-white w-4 h-4 rounded-full flex items-center justify-center text-[9px]">{activeFiltersCount}</span>}
                        </button>
                        <button onClick={onAddWorker} className="bg-blue-600 hover:bg-blue-700 text-white text-xs font-bold py-1.5 px-3 rounded-lg flex items-center gap-2 transition-colors">
                            <Plus size={16} /> Добавить
                        </button>
                    </div>
                </div>

                {showFilters && (
                    <div className="bg-slate-50 p-4 rounded-xl border border-slate-200 grid grid-cols-1 sm:grid-cols-4 gap-4 animate-in slide-in-from-top-2 duration-200">
                        <div>
                            <label className="block text-[10px] font-bold text-slate-500 uppercase mb-1">Должность</label>
                            <select value={roleFilter} onChange={(e) => setRoleFilter(e.target.value)} className="w-full text-sm border-slate-200 rounded-lg p-2 focus:ring-2 focus:ring-blue-500 outline-none">
                                <option value="">Все должности</option>
                                {uniqueRoles.map(r => <option key={r} value={r}>{r}</option>)}
                            </select>
                        </div>
                        <div>
                            <label className="block text-[10px] font-bold text-slate-500 uppercase mb-1">Линия</label>
                            <select value={lineFilter} onChange={(e) => setLineFilter(e.target.value)} className="w-full text-sm border-slate-200 rounded-lg p-2 focus:ring-2 focus:ring-blue-500 outline-none">
                                <option value="">Все линии</option>
                                {uniqueLines.map(l => <option key={l} value={l}>{l}</option>)}
                            </select>
                        </div>
                        <div>
                            <label className="block text-[10px] font-bold text-slate-500 uppercase mb-1">Статус</label>
                            <select value={statusFilter} onChange={(e) => setStatusFilter(e.target.value)} className="w-full text-sm border-slate-200 rounded-lg p-2 focus:ring-2 focus:ring-blue-500 outline-none">
                                <option value="">Все статусы</option>
                                <option value="active">Работает (Активен)</option>
                                <option value="vacation">В отпуске</option>
                                <option value="sick">На больничном</option>
                                <option value="fired">Уволен</option>
                            </select>
                        </div>
                        <div>
                            <label className="block text-[10px] font-bold text-slate-500 uppercase mb-1">Компетенция</label>
                            <input type="text" placeholder="Например: Оператор..." value={compFilter} onChange={(e) => setCompFilter(e.target.value)} className="w-full text-sm border border-slate-200 rounded-lg p-2 focus:ring-2 focus:ring-blue-500 outline-none" />
                        </div>
                        {activeFiltersCount > 0 && (
                            <div className="sm:col-span-4 flex justify-end">
                                <button onClick={clearFilters} className="text-xs text-red-500 hover:text-red-700 font-medium flex items-center gap-1">
                                    <X size={12} /> Сбросить все фильтры
                                </button>
                            </div>
                        )}
                    </div>
                )}
            </div>

            <div className="flex-1 overflow-auto p-0">
                <table className="w-full text-sm text-left">
                    <thead className="bg-slate-100 text-slate-600 sticky top-0 z-10 shadow-sm">
                        <tr>
                            <SortHeader label="ФИО" sortKey="name" />
                            <SortHeader label="Роль / Линия" sortKey="role" />
                            <SortHeader label="Компетенции" sortKey="competencies" />
                            <SortHeader label="Статус" sortKey="status" />
                            <th className="px-4 py-3 border-b w-10"></th>
                        </tr>
                    </thead>
                    <tbody className="divide-y divide-slate-100">
                        {filteredWorkers.map(worker => {
                            const status = worker.status;
                            let statusBadge = null;
                            if (status && !status.permanent && status.type !== 'active') {
                                let color = 'bg-slate-100 text-slate-500';
                                if (status.type === 'vacation') color = 'bg-emerald-100 text-emerald-700';
                                else if (status.type === 'sick') color = 'bg-amber-100 text-amber-700';
                                statusBadge = <span className={`px-2 py-1 rounded-md text-xs font-bold ${color}`}>{status.raw}</span>;
                            } else if (status && status.permanent) { // Fired
                                statusBadge = <span className="px-2 py-1 rounded-md text-xs font-bold bg-red-100 text-red-700">Уволен</span>;
                            } else {
                                statusBadge = <span className="px-2 py-1 rounded-md text-xs font-bold bg-green-50 text-green-600">Работает</span>;
                            }

                            return (
                                <tr key={worker.name} className="hover:bg-slate-50 group">
                                    <td className="px-6 py-3 font-medium text-slate-800">{worker.name}</td>
                                    <td className="px-6 py-3 text-slate-500">
                                        <div className="text-xs">{worker.role || 'Без роли'}</div>
                                        <div className="text-[10px] text-slate-400">{worker.homeLine || 'Не распределен'}</div>
                                    </td>
                                    <td className="px-6 py-3">
                                        <div className="flex flex-wrap gap-1">
                                            {worker.competencies && worker.competencies.size > 0 ? Array.from(worker.competencies).map((c, i) => (
                                                <span key={i} className="text-[10px] bg-blue-50 text-blue-600 px-1.5 py-0.5 rounded border border-blue-100">{c}</span>
                                            )) : <span className="text-slate-300 text-xs italic">-</span>}
                                        </div>
                                    </td>
                                    <td className="px-6 py-3">{statusBadge}</td>
                                    <td className="px-4 py-3 text-right">
                                        <button onClick={() => onEditWorker(worker)} className="p-1.5 text-slate-400 hover:text-blue-600 hover:bg-blue-50 rounded-lg transition-colors opacity-0 group-hover:opacity-100">
                                            <Edit3 size={16} />
                                        </button>
                                    </td>
                                </tr>
                            );
                        })}
                        {filteredWorkers.length === 0 && (
                            <tr><td colSpan={5} className="text-center py-10 text-slate-400">Ничего не найдено</td></tr>
                        )}
                    </tbody>
                </table>
            </div>
        </div>
    );
};

export default function App() {
    const [file, setFile] = useState(null);
    const [loading, setLoading] = useState(false);
    const [restoring, setRestoring] = useState(true);
    const [error, setError] = useState('');
    const [syncStatus, setSyncStatus] = useState('idle');

    const [rawTables, setRawTables] = useState({});
    const [scheduleDates, setScheduleDates] = useState([]);
    const [planHashes, setPlanHashes] = useState({});

    const [lineTemplates, setLineTemplates] = useState({});
    const [floaters, setFloaters] = useState({ day: [], night: [] });
    const [workerRegistry, setWorkerRegistry] = useState({});

    const [step, setStep] = useState('upload');
    const [viewMode, setViewMode] = useState('dashboard');
    const [selectedDate, setSelectedDate] = useState('');
    const [targetScrollBrigadeId, setTargetScrollBrigadeId] = useState(null);

    const [chessFilterShift, setChessFilterShift] = useState('all');
    const [chessSearch, setChessSearch] = useState('');
    const [chessPage, setChessPage] = useState(1);
    const [chessShowAll, setChessShowAll] = useState(false);
    const [isGlobalFill, setIsGlobalFill] = useState(false);

    const [manualAssignments, setManualAssignments] = useState({});
    const [draggedWorker, setDraggedWorker] = useState(null);
    const [updateReport, setUpdateReport] = useState(null);

    const [rvModalData, setRvModalData] = useState(null);
    const [editingWorker, setEditingWorker] = useState(null);

    // Данные сверки (СКУД)
    const [factData, setFactData] = useState(null);
    const [factDates, setFactDates] = useState([]);

    const fileInputRef = useRef(null);
    const syncTimeoutRef = useRef(null);

    const TARGET_CONFIG = [
        { tableName: 'Сводная_По_Людям', expectedSheet: 'Расписание по сменам', type: 'demand' },
        { tableName: 'Люд', expectedSheet: 'Справочник', type: 'roster' }
    ];

    // --- LOAD FROM LOCAL STORAGE ---
    useEffect(() => {
        const restoreData = () => {
            setRestoring(true);
            try {
                // Загружаем назначения
                const savedAssignments = loadFromLocalStorage(STORAGE_KEYS.MANUAL_ASSIGNMENTS, {});
                if (Object.keys(savedAssignments).length > 0) {
                    setManualAssignments(savedAssignments);
                }

                // Загружаем хеши
                const savedHashes = loadFromLocalStorage(STORAGE_KEYS.PLAN_HASHES, {});
                if (Object.keys(savedHashes).length > 0) {
                    setPlanHashes(savedHashes);
                }

                // Загружаем исходные таблицы
                const savedTables = loadFromLocalStorage(STORAGE_KEYS.RAW_TABLES, {});
                if (savedTables.demand && savedTables.roster) {
                    // Восстанавливаем даты
                    if (savedTables.demand) {
                        savedTables.demand = savedTables.demand.map((row, i) => {
                            if (i === 0) return row;
                            const dateVal = row[11];
                            if (dateVal && typeof dateVal === 'string') {
                                const d = new Date(dateVal);
                                if (!isNaN(d.getTime())) row[11] = d;
                            }
                            return row;
                        });
                    }
                    setRawTables(savedTables);
                    analyzeData(savedTables.demand, savedTables.roster);
                    setStep('dashboard');
                }

                // Загружаем дополнительные данные
                const savedTemplates = loadFromLocalStorage(STORAGE_KEYS.LINE_TEMPLATES, {});
                const savedRegistry = loadFromLocalStorage(STORAGE_KEYS.WORKER_REGISTRY, {});
                const savedFloaters = loadFromLocalStorage(STORAGE_KEYS.FLOATERS, { day: [], night: [] });
                const savedDates = loadFromLocalStorage(STORAGE_KEYS.SCHEDULE_DATES, []);

                if (Object.keys(savedTemplates).length > 0) setLineTemplates(savedTemplates);
                if (Object.keys(savedRegistry).length > 0) {
                    // Восстанавливаем Set для competencies
                    const restoredRegistry = {};
                    Object.entries(savedRegistry).forEach(([key, value]) => {
                        restoredRegistry[key] = {
                            ...value,
                            competencies: value.competencies ? new Set(value.competencies) : new Set()
                        };
                    });
                    setWorkerRegistry(restoredRegistry);
                }
                if (savedFloaters.day.length > 0 || savedFloaters.night.length > 0) setFloaters(savedFloaters);
                if (savedDates.length > 0) {
                    setScheduleDates(savedDates);
                    if (savedDates.length > 0 && !selectedDate) setSelectedDate(savedDates[0]);
                }

                // Загружаем данные сверки (СКУД)
                const savedFactData = loadFromLocalStorage(STORAGE_KEYS.FACT_DATA, null);
                const savedFactDates = loadFromLocalStorage(STORAGE_KEYS.FACT_DATES, []);
                if (savedFactData && Object.keys(savedFactData).length > 0) {
                    setFactData(savedFactData);
                }
                if (savedFactDates.length > 0) {
                    setFactDates(savedFactDates);
                }
            } catch (err) {
                console.error('Error restoring data:', err);
            } finally {
                setRestoring(false);
            }
        };
        restoreData();
    }, []);

    // Сброс пагинации табеля при изменении фильтров
    useEffect(() => {
        setChessPage(1);
    }, [chessSearch, chessFilterShift]);

    const saveSourceDataToLocal = (tables, hashes) => {
        try {
            saveToLocalStorage(STORAGE_KEYS.RAW_TABLES, tables);
            saveToLocalStorage(STORAGE_KEYS.PLAN_HASHES, hashes);
        } catch (e) {
            setError("Ошибка сохранения данных.");
        }
    };

    const debouncedSaveToLocal = useCallback(debounce((assignments) => {
        setSyncStatus('syncing');
        try {
            saveToLocalStorage(STORAGE_KEYS.MANUAL_ASSIGNMENTS, assignments);
            setSyncStatus('saved');
            if (syncTimeoutRef.current) clearTimeout(syncTimeoutRef.current);
            syncTimeoutRef.current = setTimeout(() => setSyncStatus('idle'), 2000);
        } catch (e) {
            setSyncStatus('error');
            console.error('Error saving assignments:', e);
        }
    }, 1000), []);

    const updateAssignments = (newAssignments) => {
        setManualAssignments(newAssignments);
        debouncedSaveToLocal(newAssignments);
    };

    const handleMatrixAssignment = (targetLineName, targetPosIdx, shiftId, newWorkerNames) => {
        setLineTemplates(prev => {
            const newTemplates = { ...prev };

            Object.keys(newTemplates).forEach(lineKey => {
                newTemplates[lineKey] = newTemplates[lineKey].map((pos, pIdx) => {
                    const roster = { ...pos.roster };
                    let changed = false;

                    Object.keys(roster).forEach(sId => {
                        if (lineKey === targetLineName && pIdx === targetPosIdx && sId === shiftId) return;

                        const currentCellStr = roster[sId];
                        if (currentCellStr) {
                            let names = currentCellStr.split(/[,;\n/]+/).map(s => s.trim()).filter(s => s.length > 1);
                            const hasConflict = names.some(n => newWorkerNames.includes(n));

                            if (hasConflict) {
                                names = names.filter(n => !newWorkerNames.includes(n));
                                roster[sId] = names.join(', ');
                                changed = true;
                            }
                        }
                    });

                    return changed ? { ...pos, roster } : pos;
                });
            });

            const targetLine = [...newTemplates[targetLineName]];
            const targetPos = { ...targetLine[targetPosIdx] };
            const targetRoster = { ...targetPos.roster };

            targetRoster[shiftId] = newWorkerNames.join(', ');
            targetPos.roster = targetRoster;
            targetLine[targetPosIdx] = targetPos;
            newTemplates[targetLineName] = targetLine;

            setTimeout(() => {
                setWorkerRegistry(reg => {
                    const nextReg = { ...reg };
                    newWorkerNames.forEach(name => {
                        if (!nextReg[name]) {
                            nextReg[name] = { name, role: targetPos.role, homeLine: targetLineName, competencies: new Set(), status: null };
                        } else {
                            nextReg[name] = { ...nextReg[name], homeLine: targetLineName, role: targetPos.role };
                        }
                    });
                    // Сохраняем изменения workerRegistry
                    const registryForStorage = {};
                    Object.entries(nextReg).forEach(([key, value]) => {
                        registryForStorage[key] = {
                            ...value,
                            competencies: Array.from(value.competencies || [])
                        };
                    });
                    saveToLocalStorage(STORAGE_KEYS.WORKER_REGISTRY, registryForStorage);
                    return nextReg;
                });
            }, 0);

            // Сохраняем изменения в localStorage
            saveToLocalStorage(STORAGE_KEYS.LINE_TEMPLATES, newTemplates);
            return newTemplates;
        });
    };

    const handleWorkerEditSave = ({ oldName, newName, competencies, status }) => {
        setWorkerRegistry(prev => {
            const next = { ...prev };

            if (oldName && oldName !== newName) {
                const data = next[oldName];
                delete next[oldName];
                next[newName] = { ...data, name: newName, competencies, status };

                setLineTemplates(lt => {
                    const newLt = { ...lt };
                    Object.keys(newLt).forEach(k => {
                        newLt[k] = newLt[k].map(pos => {
                            const newRoster = { ...pos.roster };
                            Object.keys(newRoster).forEach(s => {
                                if (newRoster[s] && newRoster[s].includes(oldName)) {
                                    newRoster[s] = newRoster[s].replace(oldName, newName);
                                }
                            });
                            return { ...pos, roster: newRoster };
                        });
                    });
                    return newLt;
                });
            }
            else {
                next[newName] = {
                    name: newName,
                    role: next[newName]?.role || 'Сотрудник',
                    homeLine: next[newName]?.homeLine || '',
                    competencies,
                    status
                };
            }
            // Сохраняем изменения workerRegistry
            const registryForStorage = {};
            Object.entries(next).forEach(([key, value]) => {
                registryForStorage[key] = {
                    ...value,
                    competencies: Array.from(value.competencies || [])
                };
            });
            saveToLocalStorage(STORAGE_KEYS.WORKER_REGISTRY, registryForStorage);
            return next;
        });
        setEditingWorker(null);
    };

    const handleWorkerDelete = (name) => {
        setWorkerRegistry(prev => {
            const next = { ...prev };
            delete next[name];
            // Сохраняем изменения workerRegistry
            const registryForStorage = {};
            Object.entries(next).forEach(([key, value]) => {
                registryForStorage[key] = {
                    ...value,
                    competencies: Array.from(value.competencies || [])
                };
            });
            saveToLocalStorage(STORAGE_KEYS.WORKER_REGISTRY, registryForStorage);
            return next;
        });

        setLineTemplates(lt => {
            const newLt = { ...lt };
            Object.keys(newLt).forEach(k => {
                newLt[k] = newLt[k].map(pos => {
                    const newRoster = { ...pos.roster };
                    Object.keys(newRoster).forEach(s => {
                        if (newRoster[s]) {
                            const names = newRoster[s].split(/[,;\n/]+/).map(n => n.trim());
                            const filtered = names.filter(n => n !== name);
                            newRoster[s] = filtered.join(', ');
                        }
                    });
                    return { ...pos, roster: newRoster };
                });
            });
            saveToLocalStorage(STORAGE_KEYS.LINE_TEMPLATES, newLt);
            return newLt;
        });
    };

    // Библиотеки XLSX и ExcelJS теперь импортируются локально, не требуют интернета

    const generateShiftHash = (dateStr, shiftNum, shiftType, activeLines, lineTemplates) => {
        const linesFingerprint = activeLines.sort().map(lineName => {
            const templateName = Object.keys(lineTemplates).find(t => isLineMatch(lineName, t));
            const positions = templateName ? lineTemplates[templateName] : [];
            const positionsStr = positions.map(p => `${p.role}:${p.count}`).sort().join('|');
            return `${lineName}(${positionsStr})`;
        }).join(';');
        return cyrb53(`${dateStr}|${shiftNum}|${shiftType}|${linesFingerprint}`);
    };

    const preAnalyzeRoster = (rosterData) => {
        const templates = {};
        let lastLineName = '';
        rosterData.slice(1).forEach(row => {
            let lineName = cleanVal(row[4]);
            const role = cleanVal(row[5]);
            if (!lineName && role && lastLineName) lineName = lastLineName;
            if (lineName) lastLineName = lineName;
            const countVal = cleanVal(row[6]);
            if (lineName && role && !role.toLowerCase().includes('подсобник')) {
                if (!templates[lineName]) templates[lineName] = [];
                templates[lineName].push({ role, count: parseInt(countVal) || 1 });
            }
        });
        return { templates };
    };

    const processExcelFile = async (selectedFile) => {
        if (!selectedFile) return;
        setLoading(true);
        setError('');
        setFile(selectedFile);

        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = new Uint8Array(e.target.result);
                const workbook = XLSX.read(data, { type: 'array', cellDates: true });

                const loadedData = {};
                TARGET_CONFIG.forEach(target => {
                    const sheetName = workbook.SheetNames.find(s => s.toLowerCase().includes(target.expectedSheet.toLowerCase().split('.')[0]));
                    if (sheetName) loadedData[target.type] = XLSX.utils.sheet_to_json(workbook.Sheets[sheetName], { header: 1 });
                });

                if (!loadedData['demand'] || !loadedData['roster']) throw new Error('Неверная структура файла.');

                const { templates: newTemplates } = preAnalyzeRoster(loadedData['roster']);

                const newHashes = {};
                const demandData = loadedData['demand'];
                const headers = demandData[0];

                demandData.slice(1).forEach(row => {
                    let d = row[11];
                    let dateStr = '';
                    if (d instanceof Date) dateStr = d.toLocaleDateString('ru-RU');
                    else if (typeof d === 'string') {
                        const dateTry = new Date(d);
                        if (!isNaN(dateTry.getTime())) dateStr = dateTry.toLocaleDateString('ru-RU');
                        else return;
                    } else return;

                    const shiftNum = extractShiftNumber(cleanVal(row[14]));
                    const shiftType = cleanVal(row[13]);
                    if (!shiftNum) return;

                    const activeLines = [];
                    for (let i = 15; i <= 26; i++) {
                        if ((parseInt(row[i]) || 0) > 0) activeLines.push(cleanVal(headers[i]));
                    }

                    const hash = generateShiftHash(dateStr, shiftNum, shiftType, activeLines, newTemplates);
                    newHashes[`${dateStr}_${shiftNum}`] = hash;
                });

                const oldHashes = planHashes;
                const keptAssignments = {};
                let preservedCount = 0;
                const changedDaysSet = new Set();

                Object.entries(manualAssignments).forEach(([key, assignment]) => {
                    const parts = key.split('_');
                    const date = parts[0];
                    const shift = parts[1];
                    const compositeKey = `${date}_${shift}`;

                    if (newHashes[compositeKey] && newHashes[compositeKey] === oldHashes[compositeKey]) {
                        keptAssignments[key] = assignment;
                        preservedCount++;
                    } else {
                        changedDaysSet.add(JSON.stringify({ date, shift }));
                    }
                });

                const changedDays = Array.from(changedDaysSet).map(s => JSON.parse(s));
                let sameDaysCount = 0;
                Object.keys(newHashes).forEach(k => {
                    if (oldHashes[k] === newHashes[k]) sameDaysCount++;
                });

                if (Object.keys(oldHashes).length > 0) {
                    setUpdateReport({
                        savedDays: sameDaysCount,
                        savedAssignmentsCount: preservedCount,
                        changedDays: changedDays
                    });
                }

                setManualAssignments(keptAssignments);
                setRawTables(loadedData);
                setPlanHashes(newHashes);
                analyzeData(loadedData['demand'], loadedData['roster']);

                saveSourceDataToLocal(loadedData, newHashes);
                debouncedSaveToLocal(keptAssignments);

                setStep('dashboard');

            } catch (err) { setError(err.message); } finally { setLoading(false); }
        };
        reader.readAsArrayBuffer(selectedFile);
    };

    const analyzeData = (demandData, rosterData) => {
        const rawDates = demandData.slice(1).map(row => {
            let val = row[11];
            if (val instanceof Date) return val;
            if (typeof val === 'string') {
                const d = new Date(val);
                return !isNaN(d.getTime()) ? d : null;
            }
            return null;
        }).filter(d => d);

        const uniqueTimestamps = [...new Set(rawDates.map(d => d.getTime()))].sort((a, b) => a - b);
        const sortedStringDates = uniqueTimestamps.map(ts => new Date(ts).toLocaleDateString('ru-RU'));

        setScheduleDates(sortedStringDates);
        saveToLocalStorage(STORAGE_KEYS.SCHEDULE_DATES, sortedStringDates);
        if (sortedStringDates.length > 0) setSelectedDate(prev => sortedStringDates.includes(prev) ? prev : sortedStringDates[0]);

        const templates = {};
        const floaterMap = { day: new Map(), night: new Map() };
        const registry = {};

        let lastLineName = '';

        rosterData.slice(1).forEach(row => {
            let lineName = cleanVal(row[4]);
            const role = cleanVal(row[5]);
            if (!lineName && role && lastLineName) lineName = lastLineName;
            if (lineName) lastLineName = lineName;

            const countVal = cleanVal(row[6]);
            const roleLower = role.toLowerCase();

            const shiftConfig = [
                { id: '1', n: 7, c: 8, s: 9 },
                { id: '2', n: 10, c: 11, s: 12 },
                { id: '3', n: 13, c: 14, s: 15 },
                { id: '4', n: 16, c: 17, s: 18 }
            ];

            if (roleLower.includes('подсобник') && countVal.length > 2 && !/^\d+$/.test(countVal)) {
                const names = countVal.split(/[,;\n]+/).map(n => n.trim()).filter(n => n.length > 1);
                let context = roleLower.includes('ночь') ? 'night' : 'day';
                names.forEach(name => {
                    const uniqueKey = name.replace(/\./g, '').trim().toLowerCase();
                    if (!floaterMap[context].has(uniqueKey)) {
                        floaterMap[context].set(uniqueKey, {
                            name, role, type: 'floater', shiftContext: context, id: `floater_${context}_${uniqueKey}`
                        });
                    }
                });
                return;
            }

            if (lineName && role) {
                if (!templates[lineName]) templates[lineName] = [];
                const rosterMap = {};

                shiftConfig.forEach(cfg => {
                    const rawName = cleanVal(row[cfg.n]);
                    const rawComp = cleanVal(row[cfg.c]);
                    const rawStat = cleanVal(row[cfg.s]);

                    if (rawName) {
                        rosterMap[cfg.id] = rawName;
                        const names = rawName.split(/[,;\n/]+/).map(s => s.trim()).filter(s => s.length > 1);
                        names.forEach(name => {
                            const parsedStatus = parseWorkerStatus(rawStat);
                            const comps = rawComp ? rawComp.split(/[,;]+/).map(s => s.trim()) : [];

                            if (!registry[name]) {
                                registry[name] = { name, role, homeLine: lineName, competencies: new Set(comps), status: parsedStatus };
                            } else {
                                comps.forEach(c => registry[name].competencies.add(c));
                                if (!registry[name].status && parsedStatus) registry[name].status = parsedStatus;
                            }
                        });
                    }
                });

                templates[lineName].push({ role, count: parseInt(countVal) || 1, roster: rosterMap });
            }
        });

        setLineTemplates(templates);
        setFloaters({ day: Array.from(floaterMap.day.values()), night: Array.from(floaterMap.night.values()) });
        setWorkerRegistry(registry);

        // Сохраняем в localStorage
        saveToLocalStorage(STORAGE_KEYS.LINE_TEMPLATES, templates);
        saveToLocalStorage(STORAGE_KEYS.FLOATERS, { day: Array.from(floaterMap.day.values()), night: Array.from(floaterMap.night.values()) });
        // Преобразуем Set в массив для сохранения
        const registryForStorage = {};
        Object.entries(registry).forEach(([key, value]) => {
            registryForStorage[key] = {
                ...value,
                competencies: Array.from(value.competencies || [])
            };
        });
        saveToLocalStorage(STORAGE_KEYS.WORKER_REGISTRY, registryForStorage);
    };

    const handleDragStart = (e, worker) => {
        const availability = checkWorkerAvailability(worker.name, selectedDate, workerRegistry);
        if (!availability.available) {
            e.preventDefault();
            alert(`❌ ${worker.name} недоступен: ${availability.reason}`);
            return;
        }
        setDraggedWorker(worker);
        e.dataTransfer.effectAllowed = 'move';
    };

    const handleDragOver = (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
    };

    const handleDrop = (e, targetSlotId) => {
        e.preventDefault();
        if (!draggedWorker) return;
        const assignmentEntry = { ...draggedWorker, originalId: draggedWorker.id, id: `assigned_${targetSlotId}_${Date.now()}` };
        updateAssignments({ ...manualAssignments, [targetSlotId]: assignmentEntry });
        setDraggedWorker(null);
    };

    const handleAssignRv = (worker, slotId) => {
        const assignmentEntry = {
            name: worker.name,
            role: worker.mainRole,
            homeLine: worker.homeLine,
            originalId: `rv_${worker.name}_${Date.now()}`,
            id: `assigned_${slotId}_${Date.now()}`,
            type: 'external',
            sourceShift: worker.sourceShift
        };
        updateAssignments({ ...manualAssignments, [slotId]: assignmentEntry });
        setRvModalData(null);
    };

    const handleRemoveAssignment = (slotId) => {
        const newAssignments = { ...manualAssignments };
        if (newAssignments[slotId]) delete newAssignments[slotId];
        else newAssignments[slotId] = { type: 'vacancy', id: `forced_vac_${Date.now()}` };
        updateAssignments(newAssignments);
    };

    const getShiftsForDate = useCallback((targetDate) => {
        if (!targetDate || !rawTables['demand']) return [];
        const data = rawTables['demand'];
        const headers = data[0];
        const brigadesMap = {};

        data.slice(1).forEach(row => {
            let d = row[11];
            let dateStr = '';
            if (d instanceof Date) dateStr = d.toLocaleDateString('ru-RU');
            else if (typeof d === 'string') {
                const dateTry = new Date(d);
                if (!isNaN(dateTry.getTime())) dateStr = dateTry.toLocaleDateString('ru-RU');
                else dateStr = cleanVal(d);
            }
            if (dateStr !== targetDate) return;

            const shiftType = cleanVal(row[13]);
            const brigadeRaw = cleanVal(row[14]);
            const shiftNum = extractShiftNumber(brigadeRaw);
            if (!shiftNum) return;

            if (!brigadesMap[shiftNum]) brigadesMap[shiftNum] = { id: shiftNum, name: brigadeRaw, type: shiftType, activeLines: [] };

            for (let i = 15; i <= 26; i++) {
                const lineHeader = cleanVal(headers[i]);
                if (lineHeader && (parseInt(row[i]) || 0) > 0 && !brigadesMap[shiftNum].activeLines.includes(lineHeader)) {
                    brigadesMap[shiftNum].activeLines.push(lineHeader);
                }
            }
        });

        return Object.values(brigadesMap).map(brigade => {
            const shiftTypeLower = brigade.type ? brigade.type.toLowerCase() : '';
            const lineTasks = [];
            let allShiftWorkers = [];

            Object.keys(lineTemplates).forEach(lKey => {
                lineTemplates[lKey].forEach(pos => {
                    const rawNames = pos.roster && pos.roster[brigade.id];
                    if (rawNames) {
                        rawNames.split(/[,;\n/]+/).map(s => s.trim()).filter(s => s.length > 1).forEach(name => {
                            const avail = checkWorkerAvailability(name, targetDate, workerRegistry);
                            allShiftWorkers.push({
                                name,
                                role: pos.role,
                                homeLine: lKey,
                                id: `${name}_${brigade.id}`,
                                isBusy: false,
                                isAvailable: avail.available,
                                statusReason: avail.reason
                            });
                        });
                    }
                });
            });

            const usedFloaterIds = new Set();
            Object.keys(manualAssignments).forEach(key => {
                if (key.startsWith(targetDate)) {
                    const w = manualAssignments[key];
                    if (w.type !== 'vacancy') usedFloaterIds.add(w.originalId || w.id);
                }
            });

            brigade.activeLines.forEach(activeLineName => {
                const templateName = Object.keys(lineTemplates).find(t => isLineMatch(activeLineName, t));
                const positions = templateName ? lineTemplates[templateName] : [];
                const tasksForLine = [];

                if (positions.length > 0) {
                    positions.forEach((pos) => {
                        const assignedNamesStr = pos.roster && pos.roster[brigade.id];
                        let assignedNamesList = assignedNamesStr ? assignedNamesStr.split(/[,;\n/]+/).map(s => s.trim()).filter(s => s.length > 1) : [];
                        const totalSlots = Math.max(pos.count, assignedNamesList.length);

                        for (let i = 0; i < totalSlots; i++) {
                            const slotId = `${targetDate}_${brigade.id}_${activeLineName}_${pos.role}_${i}`;
                            const currentWorkerName = assignedNamesList[i] || null;

                            let status = 'vacancy';
                            if (currentWorkerName) {
                                const wAvail = checkWorkerAvailability(currentWorkerName, targetDate, workerRegistry);
                                status = wAvail.available ? 'filled' : 'vacancy';
                            }

                            const manual = manualAssignments[slotId];
                            if (manual) status = manual.type === 'vacancy' ? 'vacancy' : 'manual';

                            if (status === 'filled' && currentWorkerName) {
                                const wAvail = checkWorkerAvailability(currentWorkerName, targetDate, workerRegistry);
                                if (!wAvail.available) status = 'vacancy';
                            }

                            tasksForLine.push({ status, roleTitle: pos.role, slotId, isManualVacancy: manualAssignments[slotId]?.type === 'vacancy', currentWorkerName, assigned: manual || (status === 'filled' ? { name: currentWorkerName } : null) });

                            if (manual && manual.type !== 'vacancy' && manual.type !== 'floater') {
                                const w = allShiftWorkers.find(w => w.id === (manual.originalId || manual.id));
                                if (w) w.isBusy = true;
                            } else if (!manual && status === 'filled') {
                                const w = allShiftWorkers.find(w => w.name === currentWorkerName && w.homeLine === templateName);
                                if (w) w.isBusy = true;
                            }
                        }
                    });
                }
                lineTasks.push({ slots: tasksForLine, displayName: templateName || activeLineName });
            });

            let freeAgents = allShiftWorkers.filter(w => !w.isBusy && w.isAvailable);

            lineTasks.forEach(lt => {
                lt.slots.forEach(slot => {
                    if (slot.status === 'vacancy' && !slot.isManualVacancy && freeAgents.length > 0) {
                        let idx = freeAgents.findIndex(a => a.role === slot.roleTitle);
                        if (idx === -1) {
                            idx = freeAgents.findIndex(a => {
                                const registryEntry = workerRegistry[a.name];
                                return registryEntry && registryEntry.competencies.has(slot.roleTitle);
                            });
                        }
                        if (idx >= 0) {
                            slot.status = 'reassigned';
                            slot.assigned = freeAgents[idx];
                            freeAgents[idx].isBusy = true;
                            freeAgents.splice(idx, 1);
                        }
                    }
                });
            });

            let baseFloaters = shiftTypeLower.includes('день') ? [...floaters.day] : [...floaters.night];
            const freeFloaters = baseFloaters.filter(f => !usedFloaterIds.has(f.id));
            const totalRequired = lineTasks.reduce((sum, lt) => sum + lt.slots.length, 0);
            const filledSlots = lineTasks.reduce((sum, lt) => sum + lt.slots.filter(s => s.status !== 'vacancy' && s.status !== 'unknown').length, 0);

            return { id: brigade.id, name: brigade.name, type: brigade.type, lineTasks, unassignedPeople: allShiftWorkers.filter(w => !w.isBusy), floaters: freeFloaters, totalRequired, filledSlots };
        });
    }, [rawTables, lineTemplates, manualAssignments, floaters, workerRegistry]);

const calculateDailyStats = useCallback((selectedDate) => {
        if (!rawTables['demand'] || !scheduleDates.length) return null;
        if (!selectedDate) return null;
        
        let totalSlots = 0;
        let filledBySystem = 0;
        let freeStaff = 0;
        let activeFloaters = 0;
        let manualEdits = 0;
        const shifts = getShiftsForDate(selectedDate);
        
        shifts.forEach(shift => {
            totalSlots += shift.totalRequired;
            filledBySystem += shift.filledSlots;
            freeStaff += shift.unassignedPeople.filter(p => p.isAvailable).length;
            activeFloaters += shift.floaters.length;
        });
        
        Object.keys(manualAssignments).forEach(k => {
            if (k.startsWith(selectedDate)) manualEdits++;
        });
        
        const vacancies = totalSlots - filledBySystem;
        let status = 'complete';
        if (vacancies > 0) status = (freeStaff + activeFloaters) >= vacancies ? 'warning' : 'critical';
        
        return { totalSlots, filledSlots: filledBySystem, vacancies, freeStaff, floatersAvailable: activeFloaters, manualEdits, status };
    }, [rawTables, manualAssignments, scheduleDates, getShiftsForDate]);

    const globalWorkSchedule = useMemo(() => {
        const schedule = {}; // Date -> Map<Name, ShiftType>
        if (scheduleDates.length === 0) return schedule;

        scheduleDates.forEach(date => {
            const shifts = getShiftsForDate(date);
            const workingMap = new Map();
            shifts.forEach(shift => {
                const shiftType = shift.type.toLowerCase().includes('ночь') ? 'Night' : 'Day';
                shift.lineTasks.forEach(t => t.slots.forEach(s => {
                    if ((s.status === 'filled' || s.status === 'manual' || s.status === 'reassigned') && s.assigned) {
                        workingMap.set(s.assigned.name, shiftType);
                    }
                }));
            });

            schedule[date] = workingMap;
        });
        return schedule;
    }, [scheduleDates, getShiftsForDate]);

    const handleAutoFillFloaters = (targetShift, isGlobal) => {
        let newAssignments = { ...manualAssignments };
        const datesToProcess = isGlobal ? scheduleDates : [selectedDate];
        datesToProcess.forEach(date => {
            const shifts = getShiftsForDate(date);
            const usedIdsForDate = new Set();
            Object.keys(newAssignments).filter(k => k.startsWith(date) && newAssignments[k].type !== 'vacancy').forEach(k => usedIdsForDate.add(newAssignments[k].originalId || newAssignments[k].id));
            shifts.forEach(shift => {
                if (!isGlobal && shift.id !== targetShift.id) return;
                const vacantSlots = [];
                shift.lineTasks.forEach(task => task.slots.forEach(slot => {
                    if (slot.status === 'vacancy' && !slot.isManualVacancy && slot.roleTitle.toLowerCase().includes('подсобник')) vacantSlots.push(slot.slotId);
                }));
                let count = 0;
                for (const floater of shift.floaters) {
                    if (count >= vacantSlots.length) break;
                    if (!usedIdsForDate.has(floater.id)) {
                        const slotId = vacantSlots[count];
                        if (!newAssignments[slotId]) {
                            newAssignments[slotId] = { ...floater, originalId: floater.id, id: `auto_${slotId}_${Date.now()}` };
                            usedIdsForDate.add(floater.id);
                            count++;
                        }
                    }
                }
            });
        });
        updateAssignments(newAssignments);
    };

    // Кэш для сопоставления сотрудников (факт ↔ план)
    const nameMatchCache = useMemo(() => new Map(), []);

    const findFactEntry = useCallback((workerName, dayFact) => {
        const normName = normalizeName(workerName);
        
        // Сначала ищем точное совпадение по нормализованному ключу
        if (dayFact[normName]) {
            return dayFact[normName];
        }

        // Используем кэш для улучшенного поиска
        if (nameMatchCache.has(normName)) {
            const cachedKey = nameMatchCache.get(normName);
            return dayFact[cachedKey] || null;
        }

        // Если не в кэше - ищем с улучшенным сопоставлением
        const found = Object.entries(dayFact).find(([key, value]) => {
            if (!value || !value.rawName) return false;
            return matchNames(workerName, value.rawName);
        });

        if (found) {
            nameMatchCache.set(normName, found[0]);
            return found[1];
        }

        return null;
    }, [nameMatchCache]);

    const calculateChessTable = useCallback(() => {
        if (!rawTables['demand'] || !rawTables['roster']) return null;
        const calendar = {};
        const data = rawTables['demand'];
        const sortedDates = [];

        data.slice(1).forEach(row => {
            let d = row[11];
            let dateStr = '';
            if (d instanceof Date) dateStr = d.toLocaleDateString('ru-RU');
            else if (typeof d === 'string') {
                const dt = new Date(d);
                if (!isNaN(dt.getTime())) dateStr = dt.toLocaleDateString('ru-RU');
            }
            if (!dateStr || dateStr.length < 5) return;
            if (!calendar[dateStr]) { calendar[dateStr] = { day: null, night: null }; if (!sortedDates.includes(dateStr)) sortedDates.push(dateStr); }
        });

        sortedDates.sort((a, b) => {
            const [d1, m1, y1] = a.split('.').map(Number);
            const [d2, m2, y2] = b.split('.').map(Number);
            return new Date(y1, m1 - 1, d1) - new Date(y2, m2 - 1, d2);
        });

        const workerMeta = new Map();
        Object.keys(lineTemplates).forEach(lineKey => {
            lineTemplates[lineKey].forEach(pos => {
                Object.entries(pos.roster).forEach(([bId, val]) => {
                    val.split(/[,;\n/]+/).map(n => n.trim()).filter(n => n.length > 1).forEach(name => {
                        if (!workerMeta.has(name)) workerMeta.set(name, { name, role: pos.role, homeLine: lineKey, homeBrigades: new Set(), category: 'staff', sortShift: 99 });
                        const w = workerMeta.get(name); w.homeBrigades.add(bId); w.sortShift = Math.min(w.sortShift, parseInt(bId) || 99);
                    });
                });
            });
        });
        floaters.day.forEach(f => { if (!workerMeta.has(f.name)) workerMeta.set(f.name, { name: f.name, role: 'Подсобник', homeLine: 'Резерв Д', homeBrigades: new Set(), category: 'floater_day', sortShift: 100 }); });
        floaters.night.forEach(f => { if (!workerMeta.has(f.name)) workerMeta.set(f.name, { name: f.name, role: 'Подсобник', homeLine: 'Резерв Н', homeBrigades: new Set(), category: 'floater_night', sortShift: 101 }); });

        const workerRows = Array.from(workerMeta.values()).sort((a, b) => (a.category === 'staff' ? a.sortShift - b.sortShift : 10) || a.name.localeCompare(b.name));

        // Добавляем людей из factData, которых нет в плане (unexpected workers)
        if (factData) {
            const unexpectedWorkersMap = new Map();

            sortedDates.forEach(date => {
                if (!factData[date]) return;

                Object.entries(factData[date]).forEach(([key, factEntry]) => {
                    if (!factEntry || (!factEntry.rawName || (!factEntry.cleanTime && !factEntry.nextDayExit))) return;

                    // Проверяем, есть ли этот человек в workerRows
                    const foundInPlan = workerRows.find(w => {
                        return normalizeName(w.name) === normalizeName(factEntry.rawName) || matchNames(w.name, factEntry.rawName);
                    });

                    // Если не найден в плане, но вышел по факту - добавляем
                    if (!foundInPlan) {
                        const normName = normalizeName(factEntry.rawName);
                        if (!unexpectedWorkersMap.has(normName)) {
                            // Ищем в реестре для получения должности
                            const regEntry = Object.values(workerRegistry).find(w => {
                                return normalizeName(w.name) === normName || matchNames(w.name, factEntry.rawName);
                            });

                            unexpectedWorkersMap.set(normName, {
                                name: factEntry.rawName,
                                role: regEntry ? regEntry.role : 'Неизвестно',
                                homeLine: 'Вне плана',
                                homeBrigades: new Set(),
                                category: 'unexpected',
                                sortShift: 102,
                                cells: {}
                            });
                        }
                    }
                });
            });

            // Добавляем unexpected workers в workerRows
            unexpectedWorkersMap.forEach(worker => {
                workerRows.push(worker);
            });

            // Пересортируем после добавления
            workerRows.sort((a, b) => (a.category === 'staff' ? a.sortShift - b.sortShift : 10) || a.name.localeCompare(b.name));
        }

        workerRows.forEach(worker => {
            worker.cells = {};
        });

        sortedDates.forEach(date => {
            const shiftsOnDate = getShiftsForDate(date);
            const workingWorkers = new Map();
            const idleWorkers = new Map();

            shiftsOnDate.forEach(shift => {
                const isNight = shift.type.toLowerCase().includes('ночь');
                const shiftCode = isNight ? 'Н' : 'Д';
                shift.lineTasks.forEach(task => {
                    task.slots.forEach(slot => {
                        if ((slot.status === 'filled' || slot.status === 'manual' || slot.status === 'reassigned') && slot.assigned) {
                            const wName = slot.assigned.name;
                            if (slot.assigned.type === 'external') {
                                workingWorkers.set(wName, { code: 'РВ', brigadeId: shift.id, isRv: true });
                            } else {
                                const current = workingWorkers.get(wName);
                                const code = current && current.code !== shiftCode && !current.isRv ? 'Д/Н' : shiftCode;
                                workingWorkers.set(wName, { code, brigadeId: shift.id });
                            }
                        }
                    });
                });
                shift.unassignedPeople.forEach(p => { if (p.isAvailable) idleWorkers.set(p.name, shift.id); });
                shift.floaters.forEach(f => idleWorkers.set(f.name, shift.id));
            });

            // Добавляем людей из factData, которых нет в плане (unexpected)
            if (factData && factData[date]) {
                Object.entries(factData[date]).forEach(([key, factEntry]) => {
                    if (!factEntry || (!factEntry.rawName || (!factEntry.cleanTime && !factEntry.nextDayExit))) return;

                    // Проверяем, есть ли этот человек в workerRows
                    const foundInPlan = workerRows.find(w => {
                        const normName = normalizeName(w.name);
                        return normName === normalizeName(factEntry.rawName) ||
                            matchNames(w.name, factEntry.rawName);
                    });

                    // Если не найден в плане, но вышел по факту - добавляем в табель
                    if (!foundInPlan) {
                        // Ищем в реестре для получения должности
                        const regEntry = Object.values(workerRegistry).find(w => {
                            return matchNames(w.name, factEntry.rawName);
                        });

                        // Создаем запись для этого работника, если еще не создана
                        let unexpectedWorker = workerRows.find(w => {
                            const normName = normalizeName(w.name);
                            return normName === normalizeName(factEntry.rawName) ||
                                matchNames(w.name, factEntry.rawName);
                        });

                        if (!unexpectedWorker) {
                            unexpectedWorker = {
                                name: factEntry.rawName,
                                role: regEntry ? regEntry.role : 'Неизвестно',
                                homeLine: 'Вне плана',
                                homeBrigades: new Set(),
                                category: 'unexpected',
                                sortShift: 102,
                                cells: {}
                            };
                            workerRows.push(unexpectedWorker);
                        }
                    }
                });
            }

            workerRows.forEach(worker => {
                let text = '';
                let color = 'bg-white';
                let brigadeId = null;
                let verificationStatus = null; // 'ok', 'missing', 'unexpected', 'unassigned', null

                const avail = checkWorkerAvailability(worker.name, date, workerRegistry);
                if (!avail.available) {
                    if (avail.type === 'vacation') { text = 'О'; color = 'bg-emerald-50 text-emerald-700 border-emerald-200'; }
                    else if (avail.type === 'sick') { text = 'Б'; color = 'bg-amber-50 text-amber-700 border-amber-200'; }
                    else if (avail.type === 'fired') { text = 'У'; color = 'bg-slate-200 text-slate-500'; }
                } else if (workingWorkers.has(worker.name)) {
                    const workData = workingWorkers.get(worker.name);
                    text = workData.code;
                    brigadeId = workData.brigadeId;
                    if (text === 'Д') color = 'bg-green-100 text-green-800 border-green-200 font-bold';
                    else if (text === 'Н') color = 'bg-blue-100 text-blue-800 border-blue-200 font-bold';
                    else if (text === 'Д/Н') color = 'bg-teal-100 text-teal-800 border-teal-200 font-bold';
                    else if (text === 'РВ') color = 'bg-orange-100 text-orange-700 border-orange-200 font-bold';

                    // Проверка сверки с фактом (СКУД)
                    if (factData && factData[date]) {
                        const normName = normalizeName(worker.name);
                        // Сначала ищем точное совпадение по нормализованному ключу
                        let factEntry = factData[date][normName];

                        // Если не нашли, ищем по улучшенному сопоставлению через rawName
                        if (!factEntry) {
                            const found = Object.entries(factData[date]).find(([key, value]) => {
                                if (!value || !value.rawName) return false;
                                return matchNames(worker.name, value.rawName);
                            });
                            if (found) factEntry = found[1];
                        }

                        // Если все еще не нашли, пробуем частичное совпадение по ключу
                        if (!factEntry) {
                            const found = Object.entries(factData[date]).find(([k, value]) => {
                                const kNorm = normalizeName(k);
                                // Проверяем по ключу
                                if (kNorm.includes(normName) || normName.includes(kNorm)) return true;
                                // Проверяем по rawName
                                if (value && value.rawName) {
                                    return matchNames(worker.name, value.rawName);
                                }
                                return false;
                            });
                            if (found) factEntry = found[1];
                        }

                        if (factEntry && (factEntry.cleanTime || factEntry.nextDayExit)) {
                            // Проверяем: был ли назначен на конкретную линию
                            // Если worker.name есть в workingWorkers - значит был назначен на линию
                            // Если нет - значит был в смене, но не на линии
                            if (workingWorkers.has(worker.name)) {
                                verificationStatus = 'ok'; // Вышел по факту и был на линии
                                // Добавляем зеленую рамку для подтвержденных выходов
                                if (!color.includes('ring-')) {
                                    color = color.replace(/border-\w+-\d+/g, '').trim() + ' ring-2 ring-green-500';
                                }
                            } else {
                                // Был в плане смены, но не на конкретной линии
                                verificationStatus = 'unassigned'; // Вышел в смену, но не стоял на линии
                            }
                        } else {
                            verificationStatus = 'missing'; // Не вышел (прогул)
                            // Добавляем красную рамку для прогулов
                            if (!color.includes('ring-')) {
                                color = color.replace(/border-\w+-\d+/g, '').trim() + ' ring-2 ring-red-500';
                            }
                        }
                    }
                } else if (idleWorkers.has(worker.name)) {
                    text = '—';
                    color = 'bg-yellow-100 text-yellow-800 border-yellow-200 font-bold';
                    brigadeId = idleWorkers.get(worker.name);

                    // Проверка сверки для людей без линии
                    if (factData && factData[date]) {
                        const normName = normalizeName(worker.name);
                        let factEntry = factData[date][normName];
                        if (!factEntry) {
                            const found = Object.entries(factData[date]).find(([key, value]) => {
                                if (!value || !value.rawName) return false;
                                return matchNames(worker.name, value.rawName);
                            });
                            if (found) factEntry = found[1];
                        }

                        if (factEntry && (factEntry.cleanTime || factEntry.nextDayExit)) {
                            verificationStatus = 'unassigned'; // Вышел в смену, но не стоял на линии
                            // Оставляем текст "—", но добавляем индикатор
                        } else {
                            // Был в смене без линии, но не вышел по факту - прогул
                            verificationStatus = 'missing'; // Не вышел (прогул)
                            // Добавляем красную рамку для прогулов
                            if (!color.includes('ring-')) {
                                color = color.replace(/border-\w+-\d+/g, '').trim() + ' ring-2 ring-red-500';
                            }
                        }
                    }
                } else {
                    // Проверка на неожиданных (вышли, но не были в плане)
                    if (factData && factData[date]) {
                        const normName = normalizeName(worker.name);
                        // Ищем по улучшенному сопоставлению
                        let factEntry = factData[date][normName];
                        if (!factEntry) {
                            const found = Object.entries(factData[date]).find(([key, value]) => {
                                return matchNames(worker.name, value.rawName);
                            });
                            if (found) factEntry = found[1];
                        }

                        if (factEntry && (factEntry.cleanTime || factEntry.nextDayExit)) {
                            verificationStatus = 'unexpected'; // Вышел, но не был в плане
                            text = '!';
                            color = 'bg-orange-50 text-orange-700 border-orange-200 font-bold';
                        }
                    }
                }

                worker.cells[date] = { text, color, brigadeId, verificationStatus };
            });
        });

        return { dates: sortedDates, workers: workerRows };
    }, [rawTables, lineTemplates, floaters, manualAssignments, workerRegistry, scheduleDates, getShiftsForDate, factData]);
    // Кэшируем результат calculateChessTable, чтобы избежать пересчета при каждом рендере
    const cachedChessTableData = useMemo(() => {
        return calculateChessTable();
    }, [calculateChessTable]);

    const exportChessTableToExcel = async () => {
        const tableData = cachedChessTableData;
        if (!tableData) {
            alert('Нет данных для экспорта');
            return;
        }

        // Используем ExcelJS для лучшего форматирования, иначе XLSX
        try {
            await exportWithExcelJS(tableData);
        } catch (err) {
            console.warn('ExcelJS export failed, trying XLSX:', err);
            exportWithXLSX(tableData);
        }
    };

    const exportWithExcelJS = async (tableData) => {
        const { dates, workers } = tableData;

        // Применяем фильтры
        const filteredWorkers = workers.filter(w => {
            if (chessSearch && !w.name.toLowerCase().includes(chessSearch.toLowerCase())) return false;
            if (chessFilterShift !== 'all') {
                if (chessFilterShift === 'floaters') return w.category.startsWith('floater');
                return w.homeBrigades.has(chessFilterShift);
            }
            return true;
        });

        const workbook = new ExcelJS.Workbook();
        const worksheet = workbook.addWorksheet('Табель');

        // Настройка ширины колонок
        worksheet.getColumn(1).width = 30; // ФИО
        worksheet.getColumn(2).width = 10; // Бригада
        worksheet.getColumn(3).width = 25; // Должность
        dates.forEach((_, idx) => {
            worksheet.getColumn(idx + 4).width = 8; // Даты
        });

        // Заголовки - форматируем даты в дд.мм
        const formattedDates = dates.map(date => {
            const [day, month] = date.split('.');
            return `${day}.${month}`;
        });
        const headerRow = worksheet.addRow(['ФИО Сотрудника', 'Бригада', 'Должность', ...formattedDates]);

        // Стили только для первой строки (шапки)
        headerRow.eachCell((cell, colNumber) => {
            cell.font = { bold: true, size: 10, color: { argb: 'FFFFFFFF' } };
            cell.fill = {
                type: 'pattern',
                pattern: 'solid',
                fgColor: { argb: 'FF4472C4' }
            };
            cell.alignment = { horizontal: 'center', vertical: 'middle', wrapText: false };
            cell.border = {
                top: { style: 'thin', color: { argb: 'FF000000' } },
                bottom: { style: 'thin', color: { argb: 'FF000000' } },
                left: { style: 'thin', color: { argb: 'FF000000' } },
                right: { style: 'thin', color: { argb: 'FF000000' } }
            };
        });
        headerRow.height = 20;

        // Данные
        filteredWorkers.forEach(worker => {
            const rowData = [
                worker.name,
                Array.from(worker.homeBrigades).join(', '),
                worker.role,
                ...dates.map(date => {
                    const cell = worker.cells[date] || { text: '', color: 'bg-white', verificationStatus: null };
                    return cell.text || '';
                })
            ];
            const row = worksheet.addRow(rowData);

            // Стиль для ФИО
            row.getCell(1).font = { size: 11 };
            row.getCell(1).alignment = { horizontal: 'left', vertical: 'middle' };
            row.getCell(1).fill = {
                type: 'pattern',
                pattern: 'solid',
                fgColor: { argb: 'FFF2F2F2' }
            };

            // Стиль для Бригады
            row.getCell(2).font = { size: 11, bold: true };
            row.getCell(2).alignment = { horizontal: 'center', vertical: 'middle' };
            row.getCell(2).fill = {
                type: 'pattern',
                pattern: 'solid',
                fgColor: { argb: 'FFE7E6E6' }
            };

            // Стиль для Должности
            row.getCell(3).font = { size: 10 };
            row.getCell(3).alignment = { horizontal: 'left', vertical: 'middle' };
            row.getCell(3).fill = {
                type: 'pattern',
                pattern: 'solid',
                fgColor: { argb: 'FFF2F2F2' }
            };

            // Стили для дат
            dates.forEach((date, dateIdx) => {
                const cell = worker.cells[date] || { text: '', color: 'bg-white', verificationStatus: null };
                const excelCell = row.getCell(dateIdx + 4);
                const cellText = cell.text || '';

                // Цвет фона
                let fillColor = 'FFFFFFFF'; // Белый
                if (cellText.includes('Д') && !cellText.includes('Д/Н')) {
                    fillColor = 'FFC6EFCE'; // Зеленый
                } else if (cellText.includes('Н')) {
                    fillColor = 'FFBDD7EE'; // Синий
                } else if (cellText.includes('Д/Н')) {
                    fillColor = 'FFB7DEE8'; // Бирюзовый
                } else if (cellText.includes('РВ')) {
                    fillColor = 'FFFFE699'; // Оранжевый
                } else if (cellText.includes('—') || cellText.includes('-')) {
                    fillColor = 'FFFFF2CC'; // Желтый
                } else if (cellText.includes('О')) {
                    fillColor = 'FFD5E8D4'; // Светло-зеленый
                } else if (cellText.includes('Б')) {
                    fillColor = 'FFFCE4D6'; // Светло-оранжевый
                } else if (cellText.includes('У')) {
                    fillColor = 'FFE2E2E2'; // Серый
                } else if (cellText.includes('!')) {
                    fillColor = 'FFFFE699'; // Оранжевый
                }

                excelCell.fill = {
                    type: 'pattern',
                    pattern: 'solid',
                    fgColor: { argb: fillColor }
                };
                excelCell.font = { size: 11, bold: true };
                excelCell.alignment = { horizontal: 'center', vertical: 'middle' };

                // Рамка для сверки
                if (cell.verificationStatus === 'ok') {
                    excelCell.border = {
                        top: { style: 'medium', color: { argb: 'FF00B050' } },
                        bottom: { style: 'medium', color: { argb: 'FF00B050' } },
                        left: { style: 'medium', color: { argb: 'FF00B050' } },
                        right: { style: 'medium', color: { argb: 'FF00B050' } }
                    };
                } else if (cell.verificationStatus === 'missing') {
                    excelCell.border = {
                        top: { style: 'medium', color: { argb: 'FFFF0000' } },
                        bottom: { style: 'medium', color: { argb: 'FFFF0000' } },
                        left: { style: 'medium', color: { argb: 'FFFF0000' } },
                        right: { style: 'medium', color: { argb: 'FFFF0000' } }
                    };
                } else {
                    excelCell.border = {
                        top: { style: 'thin', color: { argb: 'FFCCCCCC' } },
                        bottom: { style: 'thin', color: { argb: 'FFCCCCCC' } },
                        left: { style: 'thin', color: { argb: 'FFCCCCCC' } },
                        right: { style: 'thin', color: { argb: 'FFCCCCCC' } }
                    };
                }

                // Добавляем символы сверки
                if (cell.verificationStatus === 'ok') {
                    excelCell.value = (cellText || '') + ' ✓';
                } else if (cell.verificationStatus === 'missing') {
                    excelCell.value = (cellText || '') + ' ✗';
                } else if (cell.verificationStatus === 'unassigned') {
                    excelCell.value = (cellText || '') + ' ⏰';
                } else if (cell.verificationStatus === 'unexpected') {
                    excelCell.value = (cellText || '') + ' !';
                }
            });

            // Границы для всех ячеек строки
            [1, 2, 3].forEach(col => {
                const cell = row.getCell(col);
                if (!cell.border) {
                    cell.border = {
                        top: { style: 'thin', color: { argb: 'FFCCCCCC' } },
                        bottom: { style: 'thin', color: { argb: 'FFCCCCCC' } },
                        left: { style: 'thin', color: { argb: 'FFCCCCCC' } },
                        right: { style: 'thin', color: { argb: 'FFCCCCCC' } }
                    };
                }
            });
        });

        // Замораживаем первые 3 колонки и первую строку
        worksheet.views = [{
            state: 'frozen',
            xSplit: 3,
            ySplit: 1,
            topLeftCell: 'D2',
            activeCell: 'D2'
        }];

        // Настраиваем ширину колонок с датами для формата дд.мм
        dates.forEach((_, idx) => {
            worksheet.getColumn(idx + 4).width = 6; // Компактная ширина для дд.мм
        });

        // Автофильтр
        worksheet.autoFilter = {
            from: { row: 1, column: 1 },
            to: { row: filteredWorkers.length + 1, column: dates.length + 3 }
        };

        // Сохранение файла
        const today = new Date();
        const dateStr = today.toISOString().split('T')[0].replace(/-/g, '');
        const filterSuffix = chessFilterShift !== 'all' ? `_${chessFilterShift === 'floaters' ? 'Резерв' : `Бригада${chessFilterShift}`}` : '';
        const fileName = `Табель_${dateStr}${filterSuffix}.xlsx`;

        const buffer = await workbook.xlsx.writeBuffer();
        const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
        const url = window.URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = fileName;
        link.click();
        window.URL.revokeObjectURL(url);
    };

    const exportWithXLSX = (tableData) => {
        const { dates, workers } = tableData;

        // Применяем те же фильтры, что и в интерфейсе
        const filteredWorkers = workers.filter(w => {
            if (chessSearch && !w.name.toLowerCase().includes(chessSearch.toLowerCase())) return false;
            if (chessFilterShift !== 'all') {
                if (chessFilterShift === 'floaters') return w.category.startsWith('floater');
                return w.homeBrigades.has(chessFilterShift);
            }
            return true;
        });

        // Создаем данные для Excel
        const excelData = [];

        // Заголовки
        const headerRow = ['ФИО Сотрудника', 'Бригада', 'Должность', ...dates];
        excelData.push(headerRow);

        // Данные по каждому сотруднику
        filteredWorkers.forEach(worker => {
            const row = [
                worker.name,
                Array.from(worker.homeBrigades).join(', '),
                worker.role,
                ...dates.map(date => {
                    const cell = worker.cells[date] || { text: '', color: 'bg-white', verificationStatus: null };
                    let cellText = cell.text || '';

                    // Добавляем информацию о сверке, если есть
                    if (cell.verificationStatus === 'ok') {
                        cellText += ' ✓';
                    } else if (cell.verificationStatus === 'missing') {
                        cellText += ' ✗';
                    } else if (cell.verificationStatus === 'unexpected') {
                        cellText += ' !';
                    }

                    return cellText;
                })
            ];
            excelData.push(row);
        });

        // Создаем рабочую книгу
        const wb = XLSX.utils.book_new();
        const ws = XLSX.utils.aoa_to_sheet(excelData);

        // Функция для определения цвета ячейки по тексту и статусу
        const getCellStyle = (cellText, verificationStatus) => {
            const baseStyle = {
                alignment: { horizontal: 'center', vertical: 'center' },
                font: { bold: true, size: 11 },
                border: {
                    top: { style: 'thin', color: { rgb: 'CCCCCC' } },
                    bottom: { style: 'thin', color: { rgb: 'CCCCCC' } },
                    left: { style: 'thin', color: { rgb: 'CCCCCC' } },
                    right: { style: 'thin', color: { rgb: 'CCCCCC' } }
                }
            };

            // Определяем цвет фона по содержимому
            let fillColor = 'FFFFFF'; // Белый по умолчанию

            if (cellText.includes('Д')) {
                fillColor = 'C6EFCE'; // Светло-зеленый для дневной смены
            } else if (cellText.includes('Н')) {
                fillColor = 'BDD7EE'; // Светло-синий для ночной смены
            } else if (cellText.includes('Д/Н')) {
                fillColor = 'B7DEE8'; // Светло-бирюзовый для дневной/ночной
            } else if (cellText.includes('РВ')) {
                fillColor = 'FFE699'; // Светло-оранжевый для РВ
            } else if (cellText.includes('—') || cellText.includes('-')) {
                fillColor = 'FFF2CC'; // Светло-желтый для простоя
            } else if (cellText.includes('О')) {
                fillColor = 'D5E8D4'; // Светло-зеленый для отпуска
            } else if (cellText.includes('Б')) {
                fillColor = 'FCE4D6'; // Светло-оранжевый для больничного
            } else if (cellText.includes('У')) {
                fillColor = 'E2E2E2'; // Серый для уволенных
            } else if (cellText.includes('!')) {
                fillColor = 'FFE699'; // Светло-оранжевый для неожиданных
            }

            // Добавляем цвет для статуса сверки
            if (verificationStatus === 'ok') {
                // Зеленая рамка для подтвержденных
                baseStyle.border = {
                    top: { style: 'medium', color: { rgb: '00B050' } },
                    bottom: { style: 'medium', color: { rgb: '00B050' } },
                    left: { style: 'medium', color: { rgb: '00B050' } },
                    right: { style: 'medium', color: { rgb: '00B050' } }
                };
            } else if (verificationStatus === 'missing') {
                // Красная рамка для прогулов
                baseStyle.border = {
                    top: { style: 'medium', color: { rgb: 'FF0000' } },
                    bottom: { style: 'medium', color: { rgb: 'FF0000' } },
                    left: { style: 'medium', color: { rgb: 'FF0000' } },
                    right: { style: 'medium', color: { rgb: 'FF0000' } }
                };
            }

            baseStyle.fill = {
                fgColor: { rgb: fillColor }
            };

            return baseStyle;
        };

        // Применяем стили к ячейкам
        const range = XLSX.utils.decode_range(ws['!ref']);

        // Стили для заголовков
        for (let col = 0; col <= range.e.c; col++) {
            const cellAddress = XLSX.utils.encode_cell({ r: 0, c: col });
            if (!ws[cellAddress]) continue;

            ws[cellAddress].s = {
                font: { bold: true, size: 12, color: { rgb: 'FFFFFF' } },
                fill: { fgColor: { rgb: '4472C4' } }, // Синий фон для заголовков
                alignment: { horizontal: 'center', vertical: 'center', wrapText: true },
                border: {
                    top: { style: 'thin', color: { rgb: '000000' } },
                    bottom: { style: 'thin', color: { rgb: '000000' } },
                    left: { style: 'thin', color: { rgb: '000000' } },
                    right: { style: 'thin', color: { rgb: '000000' } }
                }
            };
        }

        // Стили для данных
        filteredWorkers.forEach((worker, rowIdx) => {
            // Стиль для ФИО (колонка A)
            const nameCell = XLSX.utils.encode_cell({ r: rowIdx + 1, c: 0 });
            if (ws[nameCell]) {
                ws[nameCell].s = {
                    font: { size: 11 },
                    alignment: { horizontal: 'left', vertical: 'center' },
                    border: {
                        top: { style: 'thin', color: { rgb: 'CCCCCC' } },
                        bottom: { style: 'thin', color: { rgb: 'CCCCCC' } },
                        left: { style: 'thin', color: { rgb: 'CCCCCC' } },
                        right: { style: 'thin', color: { rgb: 'CCCCCC' } }
                    },
                    fill: { fgColor: { rgb: 'F2F2F2' } }
                };
            }

            // Стиль для Бригады (колонка B)
            const brigadeCell = XLSX.utils.encode_cell({ r: rowIdx + 1, c: 1 });
            if (ws[brigadeCell]) {
                ws[brigadeCell].s = {
                    font: { size: 11, bold: true },
                    alignment: { horizontal: 'center', vertical: 'center' },
                    border: {
                        top: { style: 'thin', color: { rgb: 'CCCCCC' } },
                        bottom: { style: 'thin', color: { rgb: 'CCCCCC' } },
                        left: { style: 'thin', color: { rgb: 'CCCCCC' } },
                        right: { style: 'thin', color: { rgb: 'CCCCCC' } }
                    },
                    fill: { fgColor: { rgb: 'E7E6E6' } }
                };
            }

            // Стиль для Должности (колонка C)
            const roleCell = XLSX.utils.encode_cell({ r: rowIdx + 1, c: 2 });
            if (ws[roleCell]) {
                ws[roleCell].s = {
                    font: { size: 10 },
                    alignment: { horizontal: 'left', vertical: 'center' },
                    border: {
                        top: { style: 'thin', color: { rgb: 'CCCCCC' } },
                        bottom: { style: 'thin', color: { rgb: 'CCCCCC' } },
                        left: { style: 'thin', color: { rgb: 'CCCCCC' } },
                        right: { style: 'thin', color: { rgb: 'CCCCCC' } }
                    },
                    fill: { fgColor: { rgb: 'F2F2F2' } }
                };
            }

            // Стили для дат (колонки D+)
            dates.forEach((date, dateIdx) => {
                const cell = worker.cells[date] || { text: '', color: 'bg-white', verificationStatus: null };
                const dateCell = XLSX.utils.encode_cell({ r: rowIdx + 1, c: dateIdx + 3 });
                if (ws[dateCell]) {
                    ws[dateCell].s = getCellStyle(cell.text || '', cell.verificationStatus);
                }
            });
        });

        // Настраиваем ширину колонок
        const colWidths = [
            { wch: 30 }, // ФИО
            { wch: 10 }, // Бригада
            { wch: 25 }, // Должность
            ...dates.map(() => ({ wch: 8 })) // Даты
        ];
        ws['!cols'] = colWidths;

        // Замораживаем первые 3 колонки и первую строку
        ws['!freeze'] = { xSplit: 3, ySplit: 1, topLeftCell: 'D2', activePane: 'bottomRight', state: 'frozen' };

        // Добавляем автофильтр
        ws['!autofilter'] = { ref: `A1:${XLSX.utils.encode_cell({ r: filteredWorkers.length, c: dates.length + 2 })}` };

        // Добавляем лист в книгу
        XLSX.utils.book_append_sheet(wb, ws, 'Табель');

        // Генерируем имя файла с текущей датой
        const today = new Date();
        const dateStr = today.toISOString().split('T')[0].replace(/-/g, '');
        const filterSuffix = chessFilterShift !== 'all' ? `_${chessFilterShift === 'floaters' ? 'Резерв' : `Бригада${chessFilterShift}`}` : '';
        const fileName = `Табель_${dateStr}${filterSuffix}.xlsx`;

        // Сохраняем файл
        XLSX.writeFile(wb, fileName);
    };

    // Экспорт в JSON формат (не требует библиотек)
    const exportToJSON = () => {
        const tableData = cachedChessTableData;
        if (!tableData) {
            alert('Нет данных для экспорта');
            return;
        }

        const { dates, workers } = tableData;
        const filteredWorkers = workers.filter(w => {
            if (chessSearch && !w.name.toLowerCase().includes(chessSearch.toLowerCase())) return false;
            if (chessFilterShift !== 'all') {
                if (chessFilterShift === 'floaters') return w.category.startsWith('floater');
                return w.homeBrigades.has(chessFilterShift);
            }
            return true;
        });

        const exportData = {
            exportDate: new Date().toISOString(),
            dates: dates,
            workers: filteredWorkers.map(worker => ({
                name: worker.name,
                brigades: Array.from(worker.homeBrigades),
                role: worker.role,
                cells: dates.reduce((acc, date) => {
                    const cell = worker.cells[date] || { text: '', color: 'bg-white', verificationStatus: null };
                    acc[date] = {
                        text: cell.text || '',
                        verificationStatus: cell.verificationStatus
                    };
                    return acc;
                }, {})
            }))
        };

        const jsonStr = JSON.stringify(exportData, null, 2);
        const blob = new Blob([jsonStr], { type: 'application/json' });
        const url = window.URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;

        const today = new Date();
        const dateStr = today.toISOString().split('T')[0].replace(/-/g, '');
        const filterSuffix = chessFilterShift !== 'all' ? `_${chessFilterShift === 'floaters' ? 'Резерв' : `Бригада${chessFilterShift}`}` : '';
        link.download = `Табель_${dateStr}${filterSuffix}.json`;

        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        window.URL.revokeObjectURL(url);
    };

    // Экспорт в CSV формат (не требует библиотек)
    const exportToCSV = () => {
        const tableData = cachedChessTableData;
        if (!tableData) {
            alert('Нет данных для экспорта');
            return;
        }

        const { dates, workers } = tableData;
        const filteredWorkers = workers.filter(w => {
            if (chessSearch && !w.name.toLowerCase().includes(chessSearch.toLowerCase())) return false;
            if (chessFilterShift !== 'all') {
                if (chessFilterShift === 'floaters') return w.category.startsWith('floater');
                return w.homeBrigades.has(chessFilterShift);
            }
            return true;
        });

        // Функция для экранирования CSV значений
        const escapeCSV = (value) => {
            if (value === null || value === undefined) return '';
            const str = String(value);
            if (str.includes(',') || str.includes('"') || str.includes('\n')) {
                return `"${str.replace(/"/g, '""')}"`;
            }
            return str;
        };

        // Создаем CSV строку
        const csvRows = [];

        // Заголовки
        const headerRow = ['ФИО Сотрудника', 'Бригада', 'Должность', ...dates];
        csvRows.push(headerRow.map(escapeCSV).join(','));

        // Данные
        filteredWorkers.forEach(worker => {
            const row = [
                worker.name,
                Array.from(worker.homeBrigades).join(', '),
                worker.role,
                ...dates.map(date => {
                    const cell = worker.cells[date] || { text: '', color: 'bg-white', verificationStatus: null };
                    let cellText = cell.text || '';

                    if (cell.verificationStatus === 'ok') {
                        cellText += ' ✓';
                    } else if (cell.verificationStatus === 'missing') {
                        cellText += ' ✗';
                    } else if (cell.verificationStatus === 'unexpected') {
                        cellText += ' !';
                    }

                    return cellText;
                })
            ];
            csvRows.push(row.map(escapeCSV).join(','));
        });

        const csvContent = csvRows.join('\n');

        // Добавляем BOM для правильного отображения кириллицы в Excel
        const BOM = '\uFEFF';
        const blob = new Blob([BOM + csvContent], { type: 'text/csv;charset=utf-8;' });
        const url = window.URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;

        const today = new Date();
        const dateStr = today.toISOString().split('T')[0].replace(/-/g, '');
        const filterSuffix = chessFilterShift !== 'all' ? `_${chessFilterShift === 'floaters' ? 'Резерв' : `Бригада${chessFilterShift}`}` : '';
        link.download = `Табель_${dateStr}${filterSuffix}.csv`;

        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        window.URL.revokeObjectURL(url);
    };

    const renderChessTable = () => {
        const tableData = cachedChessTableData;
        if (!tableData) return <div className="p-10 text-center text-slate-400">Нет данных для расчета</div>;
        const { dates, workers } = tableData;
        const filteredWorkers = workers.filter(w => {
            if (chessSearch && !w.name.toLowerCase().includes(chessSearch.toLowerCase())) return false;
            if (chessFilterShift !== 'all') {
                if (chessFilterShift === 'floaters') return w.category.startsWith('floater');
                return w.homeBrigades.has(chessFilterShift);
            }
            return true;
        });

        // Пагинация
        const ITEMS_PER_PAGE = 50;
        const totalPages = Math.ceil(filteredWorkers.length / ITEMS_PER_PAGE);
        const paginatedWorkers = chessShowAll ? filteredWorkers : filteredWorkers.slice(
            (chessPage - 1) * ITEMS_PER_PAGE,
            chessPage * ITEMS_PER_PAGE
        );

        return (
            <div className="bg-white rounded-xl shadow-sm border border-slate-200 overflow-hidden flex flex-col h-full max-h-[calc(100vh-140px)]">
                <div className="p-4 border-b bg-slate-50 flex flex-col sm:flex-row justify-between items-center gap-4 flex-shrink-0">
                    <div className="flex items-center gap-4 w-full sm:w-auto">
                        <div className="font-bold text-slate-700 flex items-center gap-2"><Calendar size={20} className="text-blue-600" /> Табель</div>
                        <div className="flex items-center gap-2">
                            <button
                                onClick={exportChessTableToExcel}
                                className="flex items-center gap-2 px-3 py-1.5 bg-green-600 text-white rounded-lg text-sm font-medium hover:bg-green-700 transition-colors shadow-sm"
                                title="Выгрузить табель в Excel"
                            >
                                <Download size={16} />
                                <span className="hidden sm:inline">Excel</span>
                            </button>
                            <button
                                onClick={exportToCSV}
                                className="flex items-center gap-2 px-3 py-1.5 bg-blue-600 text-white rounded-lg text-sm font-medium hover:bg-blue-700 transition-colors shadow-sm"
                                title="Выгрузить табель в CSV (работает без интернета)"
                            >
                                <Download size={16} />
                                <span className="hidden sm:inline">CSV</span>
                            </button>
                            <button
                                onClick={exportToJSON}
                                className="flex items-center gap-2 px-3 py-1.5 bg-purple-600 text-white rounded-lg text-sm font-medium hover:bg-purple-700 transition-colors shadow-sm"
                                title="Выгрузить табель в JSON (работает без интернета)"
                            >
                                <Download size={16} />
                                <span className="hidden sm:inline">JSON</span>
                            </button>
                        </div>
                        <div className="relative">
                            <Filter size={14} className="absolute left-3 top-1/2 -translate-y-1/2 text-slate-400 pointer-events-none" />
                            <select value={chessFilterShift} onChange={(e) => setChessFilterShift(e.target.value)} className="pl-9 pr-8 py-1.5 bg-white border border-slate-200 rounded-lg text-sm font-medium text-slate-700 focus:ring-2 focus:ring-blue-500 outline-none cursor-pointer hover:border-blue-300 transition-colors">
                                <option value="all">Все смены</option>
                                <option value="1">Бригада 1</option>
                                <option value="2">Бригада 2</option>
                                <option value="3">Бригада 3</option>
                                <option value="4">Бригада 4</option>
                                <option value="floaters">Резерв</option>
                            </select>
                            <ChevronDown size={14} className="absolute right-2.5 top-1/2 -translate-y-1/2 text-slate-400 pointer-events-none" />
                        </div>
                        <div className="relative hidden sm:block">
                            <Search size={14} className="absolute left-3 top-1/2 -translate-y-1/2 text-slate-400 pointer-events-none" />
                            <input type="text" placeholder="Поиск по ФИО..." value={chessSearch} onChange={(e) => setChessSearch(e.target.value)} className="pl-9 pr-4 py-1.5 bg-white border border-slate-200 rounded-lg text-sm text-slate-700 focus:ring-2 focus:ring-blue-500 outline-none w-48" />
                            {chessSearch && <button onClick={() => setChessSearch('')} className="absolute right-2 top-1/2 -translate-y-1/2 text-slate-400 hover:text-red-500"><X size={12} /></button>}
                        </div>
                    </div>
                    <div className="flex flex-col sm:flex-row gap-3 text-xs font-medium self-end sm:self-auto">
                        <div className="flex items-center gap-2">
                            <div className="flex items-center gap-1"><div className="w-3 h-3 bg-green-100 border border-green-200 rounded"></div> Работа</div>
                            <div className="flex items-center gap-1"><div className="w-3 h-3 bg-orange-100 border border-orange-200 rounded"></div> РВ</div>
                            <div className="flex items-center gap-1"><div className="w-3 h-3 bg-yellow-100 border border-yellow-200 rounded"></div> Простой</div>
                            <div className="flex items-center gap-1"><div className="w-3 h-3 bg-emerald-50 border border-emerald-200 rounded"></div> Отпуск</div>
                        </div>
                        {factData && (
                            <div className="flex items-center gap-2 pl-2 border-l border-slate-300">
                                <div className="flex items-center gap-1" title="Вышел по факту и был на линии"><CheckCircle2 size={12} className="text-green-600" /> Вышел</div>
                                <div className="flex items-center gap-1" title="Прогул (не вышел)"><XCircle size={12} className="text-red-600" /> Прогул</div>
                                <div className="flex items-center gap-1" title="Вышел в смену, но не стоял на линии"><Clock size={12} className="text-blue-600" /> Без линии</div>
                                <div className="flex items-center gap-1" title="Вышел, но не был в плане"><AlertTriangle size={12} className="text-orange-600" /> Вне плана</div>
                            </div>
                        )}
                    </div>
                </div>
                <div className="overflow-auto flex-1">
                    <table className="w-full text-xs text-left text-slate-500 border-collapse">
                        <thead className="bg-slate-100 text-slate-700 sticky top-0 z-40 shadow-sm">
                            <tr>
                                <th className="px-4 py-3 sticky left-0 bg-slate-100 z-30 border-r border-b border-slate-200 min-w-[200px] shadow-[2px_0_4px_rgba(0,0,0,0.05)]">ФИО Сотрудника</th>
                                <th className="px-2 py-3 sticky left-[200px] bg-slate-100 z-30 border-r border-b border-slate-200 w-[60px] text-center shadow-[2px_0_4px_rgba(0,0,0,0.05)]">Бригада</th>
                                <th className="px-2 py-3 sticky left-[260px] bg-slate-100 z-30 border-r border-b border-slate-200 min-w-[150px] shadow-[2px_0_4px_rgba(0,0,0,0.05)]">Должность</th>
                                {dates.map(d => {
                                    const [day, month] = d.split('.');
                                    return <th key={d} className="px-1 py-3 text-center border-b border-r border-slate-200 min-w-[35px]"><div className="font-bold">{day}</div><div className="text-[9px] text-slate-400">{month}</div></th>;
                                })}
                            </tr>
                        </thead>
                        <tbody>
                            {paginatedWorkers.map((w, i) => (
                                <tr key={i} className="border-b border-slate-100 hover:bg-slate-50 transition-colors group">
                                    <td className="px-4 py-2 font-medium text-slate-900 sticky left-0 bg-white border-r border-slate-100 z-20 whitespace-nowrap group-hover:bg-slate-50 shadow-[2px_0_4px_rgba(0,0,0,0.05)]" title={workerRegistry[w.name]?.competencies.size > 0 ? `Компетенции: ${Array.from(workerRegistry[w.name].competencies).join(', ')}` : ''}>{w.name} {workerRegistry[w.name]?.competencies.size > 0 && <GraduationCap size={10} className="inline text-blue-400 ml-1" />}</td>
                                    <td className="px-1 py-2 sticky left-[200px] bg-white border-r border-slate-100 z-20 text-center group-hover:bg-slate-50 shadow-[2px_0_4px_rgba(0,0,0,0.05)]"><span className="px-1.5 py-0.5 rounded text-[10px] font-bold border bg-slate-100 text-slate-500 border-slate-200 inline-block">{Array.from(w.homeBrigades).join(',')}</span></td>
                                    <td className="px-2 py-2 text-slate-500 sticky left-[260px] bg-white border-r border-slate-100 z-20 truncate max-w-[150px] group-hover:bg-slate-50 shadow-[2px_0_4px_rgba(0,0,0,0.05)]">{w.role}</td>
                                    {dates.map(d => {
                                        const cell = w.cells[d] || { text: '', color: 'bg-white', verificationStatus: null };
                                        return (
                                            <td
                                                key={d}
                                                onClick={() => {
                                                    if (cell.brigadeId) {
                                                        setSelectedDate(d);
                                                        setTargetScrollBrigadeId(cell.brigadeId);
                                                        setViewMode('dashboard');
                                                    }
                                                }}
                                                className={`border-r border-slate-100 text-center p-0 h-10 ${cell.color} border-b relative ${cell.brigadeId ? 'cursor-pointer hover:brightness-95' : ''} transition-all`}
                                                title={
                                                    cell.verificationStatus === 'ok' ? '✓ Вышел по факту и был на линии (СКУД)' :
                                                        cell.verificationStatus === 'missing' ? '✗ Прогул - не вышел по факту (СКУД)' :
                                                            cell.verificationStatus === 'unassigned' ? '⏰ Вышел в смену, но не стоял на линии' :
                                                                cell.verificationStatus === 'unexpected' ? '! Вышел, но не был в плане' :
                                                                    ''
                                                }
                                            >
                                                <div className="w-full h-full flex items-center justify-center font-bold relative overflow-visible">
                                                    <span className="relative z-10 leading-none">{cell.text}</span>
                                                    {cell.verificationStatus === 'ok' && (
                                                        <div className="absolute -top-1 -right-1 pointer-events-none z-30">
                                                            <div className="bg-green-500 rounded-full p-0.5 shadow-md border-2 border-white">
                                                                <CheckCircle2 size={6} className="text-white" strokeWidth={2.5} fill="currentColor" />
                                                            </div>
                                                        </div>
                                                    )}
                                                    {cell.verificationStatus === 'missing' && (
                                                        <div className="absolute -top-1 -right-1 pointer-events-none z-30">
                                                            <div className="bg-red-500 rounded-full p-0.5 shadow-md border-2 border-white">
                                                                <XCircle size={6} className="text-white" strokeWidth={2.5} fill="currentColor" />
                                                            </div>
                                                        </div>
                                                    )}
                                                    {cell.verificationStatus === 'unassigned' && (
                                                        <div className="absolute -top-1 -right-1 pointer-events-none z-30">
                                                            <div className="bg-blue-500 rounded-full p-0.5 shadow-md border-2 border-white">
                                                                <Clock size={6} className="text-white" strokeWidth={2.5} fill="currentColor" />
                                                            </div>
                                                        </div>
                                                    )}
                                                    {cell.verificationStatus === 'unexpected' && (
                                                        <div className="absolute -top-1 -right-1 pointer-events-none z-30">
                                                            <div className="bg-orange-500 rounded-full p-0.5 shadow-md border-2 border-white">
                                                                <AlertTriangle size={6} className="text-white" strokeWidth={2.5} fill="currentColor" />
                                                            </div>
                                                        </div>
                                                    )}
                                                </div>
                                            </td>
                                        );
                                    })}
                                </tr>
                            ))}
                        </tbody>
                    </table>
                    
                    {/* Панель пагинации */}
                    <div className="border-t border-slate-200 p-4 bg-slate-50 flex flex-col sm:flex-row justify-between items-center gap-4">
                        <div className="flex items-center gap-4 text-sm text-slate-600">
                            <span>Показано <b>{paginatedWorkers.length}</b> из <b>{filteredWorkers.length}</b> записей</span>
                            {!chessShowAll && filteredWorkers.length > ITEMS_PER_PAGE && (
                                <span>Страница {chessPage} из {totalPages}</span>
                            )}
                        </div>
                        <div className="flex items-center gap-2">
                            {!chessShowAll && filteredWorkers.length > ITEMS_PER_PAGE && (
                                <>
                                    <button
                                        onClick={() => setChessPage(Math.max(1, chessPage - 1))}
                                        disabled={chessPage === 1}
                                        className="px-3 py-1.5 bg-white border border-slate-200 rounded-lg text-sm font-medium text-slate-600 hover:bg-slate-50 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
                                    >
                                        ←
                                    </button>
                                    <div className="flex items-center gap-1">
                                        {Array.from({ length: Math.min(5, totalPages) }, (_, i) => {
                                            let pageNum;
                                            if (totalPages <= 5) {
                                                pageNum = i + 1;
                                            } else if (chessPage <= 3) {
                                                pageNum = i + 1;
                                            } else if (chessPage >= totalPages - 2) {
                                                pageNum = totalPages - 4 + i;
                                            } else {
                                                pageNum = chessPage - 2 + i;
                                            }
                                            return (
                                                <button
                                                    key={pageNum}
                                                    onClick={() => setChessPage(pageNum)}
                                                    className={`px-3 py-1.5 rounded-lg text-sm font-medium transition-colors ${
                                                        chessPage === pageNum 
                                                            ? 'bg-blue-600 text-white' 
                                                            : 'bg-white border border-slate-200 text-slate-600 hover:bg-slate-50'
                                                    }`}
                                                >
                                                    {pageNum}
                                                </button>
                                            );
                                        })}
                                    </div>
                                    <button
                                        onClick={() => setChessPage(Math.min(totalPages, chessPage + 1))}
                                        disabled={chessPage === totalPages}
                                        className="px-3 py-1.5 bg-white border border-slate-200 rounded-lg text-sm font-medium text-slate-600 hover:bg-slate-50 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
                                    >
                                        →
                                    </button>
                                </>
                            )}
                            <button
                                onClick={() => {
                                    setChessShowAll(!chessShowAll);
                                    if (!chessShowAll) setChessPage(1);
                                }}
                                className={`px-4 py-1.5 rounded-lg text-sm font-medium transition-colors ${
                                    chessShowAll 
                                        ? 'bg-orange-100 text-orange-700 border border-orange-200' 
                                        : 'bg-blue-600 text-white hover:bg-blue-700'
                                }`}
                            >
                                {chessShowAll ? 'Ограничить' : 'Показать все'}
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        );
    };

    const renderDashboard = () => {
        const shiftsData = getShiftsForDate(selectedDate);
        const dayStats = calculateDailyStats(selectedDate);
        return (
            <div className="pb-20">
                <DayStatusHeader stats={dayStats} date={selectedDate} />
                {rvModalData && (
                    <RvPickerModal
                        isOpen={!!rvModalData}
                        onClose={() => setRvModalData(null)}
                        slotData={rvModalData}
                        lineTemplates={lineTemplates}
                        workerRegistry={workerRegistry}
                        globalSchedule={globalWorkSchedule}
                        scheduleDates={scheduleDates}
                        currentShiftId={rvModalData.currentShiftId}
                        onAssign={handleAssignRv}
                    />
                )}
                <div className="space-y-12">
                    {shiftsData.map((shift) => (
                        <div id={`brigade-${shift.id}`} key={shift.id} className="bg-white rounded-2xl shadow-sm border border-slate-200 overflow-hidden">
                            <div className="px-6 py-4 border-b flex items-center justify-between bg-slate-50">
                                <div className="flex items-center gap-4">
                                    <div className="p-3 rounded-xl bg-blue-600 text-white font-bold text-xl">{shift.name}</div>
                                    <div>
                                        <div className="font-semibold text-slate-700 text-lg flex items-center gap-2">{shift.type}</div>
                                        <div className="text-sm text-slate-500">Мест: <b>{shift.totalRequired}</b> | Занято: <b>{shift.filledSlots}</b></div>
                                    </div>
                                </div>
                                <div className="flex items-center gap-3">
                                    <label className="flex items-center gap-2 text-sm font-medium text-slate-600 bg-slate-50 px-3 py-2 rounded-lg border border-slate-200 cursor-pointer hover:bg-slate-100 transition-colors select-none">
                                        {isGlobalFill ? <CheckSquare size={18} className="text-blue-600" /> : <Square size={18} className="text-slate-400" />} <span>Заполнить глобально</span> <input type="checkbox" className="hidden" checked={isGlobalFill} onChange={(e) => setIsGlobalFill(e.target.checked)} />
                                    </label>
                                    {shift.floaters.length > 0 && shift.filledSlots < shift.totalRequired && (<button onClick={() => handleAutoFillFloaters(shift, isGlobalFill)} className="flex items-center gap-2 bg-yellow-100 text-yellow-700 px-4 py-2 rounded-lg font-bold hover:bg-yellow-200 transition-colors shadow-sm active:transform active:scale-95"><Wand2 size={18} /> Заполнить подсобниками</button>)}
                                </div>
                            </div>
                            <div className="p-6 bg-slate-100/50">
                                <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-6">
                                    {shift.lineTasks.map((task, idx) => (
                                        <div key={idx} className="bg-white rounded-xl border border-slate-200 shadow-sm flex flex-col overflow-hidden">
                                            <div className="bg-slate-50 px-4 py-2 border-b border-slate-100 flex justify-between items-center">
                                                <h3 className="font-bold text-slate-700 text-sm truncate" title={task.displayName}>{task.displayName}</h3>
                                                <span className="text-xs font-semibold bg-white border border-slate-200 px-2 py-0.5 rounded text-slate-500">{task.slots.length} мест</span>
                                            </div>
                                            <div className="p-3 space-y-2 flex-1">
                                                {task.slots.map((slot, sIdx) => {
                                                    const wName = slot.assigned?.name;
                                                    const reg = wName ? workerRegistry[wName] : null;
                                                    const isCompFill = reg && reg.competencies.has(slot.roleTitle);

                                                    if (slot.assigned?.type === 'external') {
                                                        return (
                                                            <div key={sIdx} className="bg-orange-50 border-orange-200 border-2 p-2 rounded-lg relative group">
                                                                <button onClick={() => handleRemoveAssignment(slot.slotId)} className="absolute -top-2 -right-2 bg-red-500 text-white rounded-full p-0.5 opacity-0 group-hover:opacity-100 transition-opacity shadow-sm z-10 cursor-pointer"><X size={12} /></button>
                                                                <div className="absolute top-0 right-0 bg-orange-500 text-white text-[9px] px-1.5 py-0.5 rounded-bl font-bold">РВ • Бр.{slot.assigned.sourceShift}</div>
                                                                <div className="flex items-center gap-2">
                                                                    <div className="w-8 h-8 bg-orange-200 text-orange-700 rounded-full flex items-center justify-center font-bold text-xs">{slot.assigned.name[0]}</div>
                                                                    <div className="min-w-0"><div className="font-semibold text-slate-700 text-sm truncate">{slot.assigned.name}</div><div className="text-xs text-slate-500 truncate">{slot.assigned.role}</div></div>
                                                                </div>
                                                            </div>
                                                        );
                                                    }

                                                    const renderFilled = (statusColor, borderColor, iconBg, iconColor, assignedWorker, isManual = false) => (
                                                        <div className={`flex items-center gap-3 p-2 rounded-lg ${statusColor} border ${borderColor} relative group`}>
                                                            {(slot.status === 'filled' || isManual || slot.status === 'reassigned') && (
                                                                <button onClick={() => handleRemoveAssignment(slot.slotId)} className="absolute -top-2 -right-2 bg-red-500 text-white rounded-full p-0.5 opacity-0 group-hover:opacity-100 transition-opacity shadow-sm z-10 cursor-pointer"> <X size={12} /> </button>
                                                            )}
                                                            <div className={`w-8 h-8 rounded-full ${iconBg} ${iconColor} flex items-center justify-center text-xs font-bold flex-shrink-0`}>{typeof assignedWorker.name === 'string' ? assignedWorker.name.substring(0, 1) : '?'}</div>
                                                            <div className="min-w-0 flex-1">
                                                                <div className="text-sm font-semibold text-slate-700 truncate">{typeof assignedWorker.name === 'string' ? assignedWorker.name : 'Error'}</div>
                                                                <div className="text-[10px] text-slate-500 truncate flex items-center gap-1">
                                                                    {assignedWorker.role} {isManual && <span className="text-blue-600 font-bold ml-1">★</span>}
                                                                    {isCompFill && <span title="По компетенции"><GraduationCap size={10} className="text-blue-500 ml-1 inline" /></span>}
                                                                </div>
                                                            </div>
                                                        </div>
                                                    );
                                                    if (slot.status === 'filled') return <div key={sIdx}>{renderFilled('bg-green-50', 'border-green-100', 'bg-green-200', 'text-green-700', slot.assigned)}</div>;
                                                    else if (slot.status === 'reassigned') return <div key={sIdx} className="relative">{renderFilled('bg-blue-50', 'border-blue-100', 'bg-blue-200', 'text-blue-700', slot.assigned)}<div className="absolute top-0 right-0 bg-blue-200 text-blue-700 px-1.5 py-0.5 rounded-bl text-[9px] font-bold pointer-events-none"><ArrowRightLeft size={8} className="inline mr-0.5" />{slot.assigned.homeLine}</div></div>;
                                                    else if (slot.status === 'manual') return <div key={sIdx}>{renderFilled('bg-indigo-50', 'border-indigo-200', 'bg-indigo-200', 'text-indigo-700', slot.assigned, true)}</div>;
                                                    else return (
                                                        <div key={sIdx} onDragOver={handleDragOver} onDrop={(e) => handleDrop(e, slot.slotId)} className={`flex items-center gap-3 p-2 rounded-lg border-2 border-dashed ${draggedWorker ? 'border-blue-400 bg-blue-50' : 'border-red-200 bg-red-50/30'} transition-colors relative group`}>
                                                            {slot.isManualVacancy && <button onClick={() => handleRemoveAssignment(slot.slotId)} className="absolute -top-2 -right-2 bg-gray-400 text-white rounded-full p-0.5 opacity-0 group-hover:opacity-100 transition-opacity shadow-sm z-10"><X size={12} /></button>}
                                                            <div className={`w-8 h-8 rounded-full ${draggedWorker ? 'bg-blue-100 text-blue-500' : 'bg-red-100 text-red-400'} flex items-center justify-center flex-shrink-0`}><UserPlus size={16} /></div>
                                                            <div className="flex-1">
                                                                <div className={`text-sm font-bold ${draggedWorker ? 'text-blue-500' : 'text-red-400'}`}>{draggedWorker ? 'Поставить' : (slot.isManualVacancy ? 'Закрыто' : 'Требуется')}</div>
                                                                <div className={`text-xs font-bold ${draggedWorker ? 'text-blue-400' : 'text-slate-600'}`}>{slot.roleTitle}</div>
                                                            </div>
                                                            {!draggedWorker && !slot.isManualVacancy && (
                                                                <button
                                                                    onClick={() => setRvModalData({ date: selectedDate, roleTitle: slot.roleTitle, slotId: slot.slotId, currentShiftId: shift.id, currentShiftType: shift.type })}
                                                                    className="bg-orange-100 hover:bg-orange-200 text-orange-600 p-1.5 rounded-lg transition-colors"
                                                                    title="Назначить РВ"
                                                                >
                                                                    <UserPlus size={16} />
                                                                </button>
                                                            )}
                                                        </div>
                                                    );
                                                })}
                                            </div>
                                        </div>
                                    ))}
                                </div>
                                <div className="mt-8 grid grid-cols-1 md:grid-cols-2 gap-6">
                                    <div className="bg-white rounded-xl border border-yellow-200 shadow-sm p-4 relative overflow-hidden">
                                        <div className="absolute top-0 left-0 w-1 h-full bg-yellow-400"></div>
                                        <h4 className="font-bold text-slate-700 mb-3 flex items-center gap-2">{shift.type.toLowerCase().includes('день') ? <Sun size={18} className="text-yellow-500" /> : <Moon size={18} className="text-slate-600" />}Резерв ({shift.floaters.length})</h4>
                                        <div className="grid grid-cols-1 sm:grid-cols-2 gap-2">{shift.floaters.length > 0 ? shift.floaters.map(p => (<div key={p.id} draggable onDragStart={(e) => handleDragStart(e, p)} className="flex items-center gap-2 p-2 bg-yellow-50 rounded border border-yellow-100 cursor-grab active:cursor-grabbing hover:shadow-md transition-shadow group"><GripVertical size={14} className="text-yellow-400" /><div className="text-xs font-semibold text-slate-700">{p.name}</div></div>)) : <div className="text-xs text-slate-400 italic">Пусто</div>}</div>
                                    </div>
                                    <div className="bg-white rounded-xl border border-slate-200 shadow-sm p-4 relative overflow-hidden">
                                        <div className="absolute top-0 left-0 w-1 h-full bg-slate-300"></div>
                                        <h4 className="font-bold text-slate-700 mb-3 flex items-center gap-2"><Users size={18} className="text-slate-500" />Свободные сотрудники ({shift.unassignedPeople.length})</h4>
                                        <div className="grid grid-cols-1 sm:grid-cols-2 gap-2 max-h-40 overflow-y-auto pr-2">{shift.unassignedPeople.map(p => (
                                            <div key={p.id} draggable={p.isAvailable} onDragStart={(e) => handleDragStart(e, p)} className={`flex items-center gap-2 p-2 rounded border transition-shadow ${p.isAvailable ? 'bg-slate-50 border-slate-100 cursor-grab active:cursor-grabbing hover:shadow-md' : 'bg-slate-100 border-slate-200 opacity-60 cursor-not-allowed'}`} title={!p.isAvailable ? p.statusReason : (workerRegistry[p.name]?.competencies.size > 0 ? `Компетенции: ${Array.from(workerRegistry[p.name].competencies).join(', ')}` : '')}>
                                                {p.isAvailable ? <GripVertical size={14} className="text-slate-300" /> : <Ban size={14} className="text-red-400" />}
                                                <div className="min-w-0"><div className="text-xs font-semibold text-slate-700 truncate flex items-center gap-1">{p.name} {workerRegistry[p.name]?.competencies.size > 0 && <GraduationCap size={10} className="text-blue-400" />}</div><div className="text-[9px] text-slate-400 truncate">{!p.isAvailable ? <span className="text-red-500 font-bold">{p.statusReason}</span> : `${p.role} (${p.homeLine})`}</div></div>
                                            </div>
                                        ))}</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    ))}
                </div>
            </div>
        );
    };

    const renderContent = () => {
        switch (viewMode) {
            case 'dashboard': return <div className="h-full overflow-y-auto pr-2">{renderDashboard()}</div>;
            case 'chess': return renderChessTable();
            case 'employees_list': return <EmployeeListView workerRegistry={workerRegistry} onEditWorker={setEditingWorker} onAddWorker={() => setEditingWorker('new')} />;
            case 'employees_roster': return <DistributionView lineTemplates={lineTemplates} workerRegistry={workerRegistry} floaters={floaters} onMatrixUpdate={handleMatrixAssignment} />;
            case 'tables': return <div className="h-full overflow-y-auto space-y-8 pb-20">{Object.entries(rawTables).map(([k, d]) => <div key={k} className="bg-white rounded-xl shadow border border-slate-200 overflow-hidden"><div className="px-6 py-4 bg-slate-50 border-b font-bold capitalize flex gap-2"><Database size={18} className="text-blue-500" />{k === 'demand' ? 'Потребность' : 'Штат'}</div><div className="overflow-auto max-h-96"><table className="w-full text-xs text-left"><thead><tr>{d[0].map((h, i) => <th key={i} className="border-r border-b px-2 py-1 bg-slate-100">{h}</th>)}</tr></thead><tbody>{d.slice(1).map((r, i) => <tr key={i}>{r.map((c, j) => <td key={j} className="border-r border-b px-2 py-1 truncate max-w-[150px]">{String(c)}</td>)}</tr>)}</tbody></table></div></div>)}</div>;
            case 'verification': return <VerificationView getShiftsForDate={getShiftsForDate} workerRegistry={workerRegistry} factData={factData} setFactData={setFactData} factDates={factDates} setFactDates={setFactDates} />;
            default: return null;
        }
    };

    return (
        <div className="h-screen bg-slate-100 font-sans text-slate-800 flex flex-col overflow-hidden">
            <UpdateReportModal data={updateReport} onClose={() => setUpdateReport(null)} />
            {editingWorker && (
                <EditWorkerModal
                    worker={editingWorker === 'new' ? null : editingWorker}
                    onClose={() => setEditingWorker(null)}
                    onSave={handleWorkerEditSave}
                    onDelete={handleWorkerDelete}
                    workerRegistry={workerRegistry}
                    lineTemplates={lineTemplates}
                />
            )}
            {step === 'upload' ? (
                <div className="min-h-screen bg-slate-50 flex flex-col items-center justify-center p-6 w-full">
                    <div className="w-full max-w-lg space-y-8 text-center">
                        <div><h1 className="text-3xl font-bold text-slate-900 mb-2">Управление сменами</h1><p className="text-slate-500">Загрузите файл для расчета</p></div>
                        {restoring ? <div className="flex flex-col items-center justify-center p-10 gap-4"><Loader2 className="animate-spin text-blue-500" size={40} /><p className="text-slate-500 text-sm font-medium">Проверка данных...</p></div> :
                            <div
                                onClick={() => fileInputRef.current?.click()}
                                className="bg-white border-2 border-dashed border-blue-200 hover:border-blue-400 hover:bg-blue-50/50 rounded-2xl p-10 cursor-pointer transition-all shadow-xl shadow-blue-900/5 group"
                                style={{ position: 'relative', minHeight: '200px' }}
                            >
                                <input
                                    type="file"
                                    ref={fileInputRef}
                                    onChange={(e) => processExcelFile(e.target.files[0])}
                                    className="hidden"
                                    accept=".xlsx, .xls"
                                    style={{ display: 'none', visibility: 'hidden', position: 'absolute', width: 0, height: 0 }}
                                />
                                <div className="flex flex-col items-center gap-4">
                                    {loading ? (
                                        <Loader2 className="animate-spin text-blue-600" size={48} />
                                    ) : (
                                        <div className="bg-blue-100 p-5 rounded-full text-blue-600 group-hover:scale-110 transition-transform">
                                            <Upload size={40} />
                                        </div>
                                    )}
                                    <div>
                                        <p className="text-xl font-bold text-slate-700">{file ? file.name : 'Нажмите для загрузки'}</p>
                                        {!file && <p className="text-slate-400 mt-2">.xlsx файл</p>}
                                    </div>
                                </div>
                            </div>}
                        {error && <div className="bg-red-50 border border-red-200 text-red-700 p-4 rounded-xl flex items-center justify-center gap-2 text-sm"><AlertCircle size={18} /><span>{error}</span></div>}
                    </div>
                </div>
            ) : (
                <>
                    <div className="bg-white border-b border-slate-200 shadow-sm px-6 py-3 flex-shrink-0">
                        <div className="max-w-[1800px] mx-auto flex flex-col md:flex-row md:items-center justify-between gap-4">
                            <div className="flex items-center gap-3"><div className="bg-blue-600 text-white p-2 rounded-lg"><Briefcase size={24} /></div><div><h1 className="text-xl font-bold text-slate-800">Планировщик</h1><p className="text-xs text-slate-500 hidden sm:block">План/Факт</p></div></div>
                            <div className="flex items-center gap-3">
                                <div className="flex items-center gap-2 mr-4">
                                    {syncStatus === 'syncing' && <div className="text-xs text-blue-500 flex items-center gap-1"><Loader2 size={12} className="animate-spin" /></div>}
                                    {syncStatus === 'saved' && <div className="text-xs text-green-500 flex items-center gap-1" title="Сохранено локально"><Save size={14} /></div>}
                                    {syncStatus === 'error' && <div className="text-xs text-red-500 flex items-center gap-1" title="Ошибка сохранения"><AlertCircle size={14} /></div>}
                                </div>
                                <div className="bg-slate-100 p-1 rounded-lg flex border border-slate-200">
                                    <button onClick={() => setViewMode('dashboard')} className={`flex items-center gap-2 px-3 py-1.5 rounded-md text-sm font-medium transition-all ${viewMode === 'dashboard' ? 'bg-white text-blue-600 shadow-sm' : 'text-slate-500 hover:text-slate-700'}`}><LayoutGrid size={16} /> Смены</button>
                                    <button onClick={() => setViewMode('chess')} className={`flex items-center gap-2 px-3 py-1.5 rounded-md text-sm font-medium transition-all ${viewMode === 'chess' ? 'bg-white text-blue-600 shadow-sm' : 'text-slate-500 hover:text-slate-700'}`}><Grid3X3 size={16} /> Табель</button>

                                    {/* Split Employees Menu */}
                                    <div className="flex items-center border-l border-slate-300 ml-2 pl-2 gap-1">
                                        <button onClick={() => setViewMode('employees_list')} className={`flex items-center gap-2 px-3 py-1.5 rounded-md text-sm font-medium transition-all ${viewMode === 'employees_list' ? 'bg-white text-blue-600 shadow-sm' : 'text-slate-500 hover:text-slate-700'}`}><Users size={16} /> Список</button>
                                        <button onClick={() => setViewMode('employees_roster')} className={`flex items-center gap-2 px-3 py-1.5 rounded-md text-sm font-medium transition-all ${viewMode === 'employees_roster' ? 'bg-white text-blue-600 shadow-sm' : 'text-slate-500 hover:text-slate-700'}`}><LayoutGrid size={16} /> Распределение</button>
                                    </div>

                                    {/* Verification Menu Item */}
                                    <div className="flex items-center border-l border-slate-300 ml-2 pl-2">
                                        <button onClick={() => setViewMode('verification')} className={`flex items-center gap-2 px-3 py-1.5 rounded-md text-sm font-medium transition-all ${viewMode === 'verification' ? 'bg-white text-blue-600 shadow-sm' : 'text-slate-500 hover:text-slate-700'}`}><FileCheck size={16} /> Сверка</button>
                                    </div>

                                    <button onClick={() => setViewMode('tables')} className={`flex items-center gap-2 px-3 py-1.5 rounded-md text-sm font-medium transition-all ${viewMode === 'tables' ? 'bg-white text-blue-600 shadow-sm' : 'text-slate-500 hover:text-slate-700'}`}><Database size={16} /> БД</button>
                                </div>
                                {viewMode === 'dashboard' && <CustomDateSelector dates={scheduleDates} selectedDate={selectedDate} onSelect={setSelectedDate} getStatsByDate={calculateDailyStats} />}
                                <div className="h-8 w-px bg-slate-200 mx-2"></div>
                                <button onClick={() => { setStep('upload'); setRawTables({}); }} className="text-sm text-slate-500 hover:text-blue-600 font-medium px-3 py-2 hover:bg-blue-50 rounded-lg transition-colors whitespace-nowrap flex items-center gap-2"><FileUp size={16} /><span>Новый</span></button>
                            </div>
                        </div>
                    </div>
                    <div className="flex-1 overflow-hidden p-4 sm:p-6 w-full max-w-[1800px] mx-auto">
                        {renderContent()}
                    </div>
                </>
            )}
        </div>
    );
}